
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>utool.util_list &#8212; wbia-vtool 3.0.1 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for utool.util_list</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">six</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">floor</span><span class="p">,</span> <span class="n">ceil</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="nb">zip</span><span class="p">,</span> <span class="nb">map</span><span class="p">,</span> <span class="n">zip_longest</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">utool</span> <span class="k">import</span> <span class="n">util_iter</span>
<span class="kn">from</span> <span class="nn">utool</span> <span class="k">import</span> <span class="n">util_inject</span>
<span class="kn">from</span> <span class="nn">utool</span> <span class="k">import</span> <span class="n">util_str</span>
<span class="kn">from</span> <span class="nn">utool</span> <span class="k">import</span> <span class="n">util_type</span>
<span class="kn">from</span> <span class="nn">utool._internal.meta_util_six</span> <span class="k">import</span> <span class="n">get_funcname</span><span class="p">,</span> <span class="n">set_funcname</span>

<span class="nb">print</span><span class="p">,</span> <span class="n">rrr</span><span class="p">,</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">util_inject</span><span class="o">.</span><span class="n">inject2</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="k">if</span> <span class="n">util_type</span><span class="o">.</span><span class="n">HAVE_NUMPY</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>


<span class="c1"># --- List Allocations ---</span>


<div class="viewcode-block" id="emap"><a class="viewcode-back" href="../../utool.html#utool.util_list.emap">[docs]</a><span class="k">def</span> <span class="nf">emap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">iter_</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Eager version of the builtin map function.</span>
<span class="sd">    This provides the same functionality as python2 map.</span>

<span class="sd">    Note this is inefficient and should only be used when prototyping and</span>
<span class="sd">    debugging.</span>

<span class="sd">    Extended functionality supports passing common kwargs to all functions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">iter_</span><span class="p">]</span></div>
    <span class="c1"># return list(map(func, iter_))</span>


<div class="viewcode-block" id="estarmap"><a class="viewcode-back" href="../../utool.html#utool.util_list.estarmap">[docs]</a><span class="k">def</span> <span class="nf">estarmap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">iter_</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Eager version of it.starmap from itertools</span>

<span class="sd">    Note this is inefficient and should only be used when prototyping and</span>
<span class="sd">    debugging.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">iter_</span><span class="p">]</span></div>


<div class="viewcode-block" id="ezip"><a class="viewcode-back" href="../../utool.html#utool.util_list.ezip">[docs]</a><span class="k">def</span> <span class="nf">ezip</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Eager version of the builtin zip function.</span>
<span class="sd">    This provides the same functionality as python2 zip.</span>

<span class="sd">    Note this is inefficient and should only be used when prototyping and</span>
<span class="sd">    debugging.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span></div>


<span class="n">lmap</span> <span class="o">=</span> <span class="n">emap</span>
<span class="n">lzip</span> <span class="o">=</span> <span class="n">ezip</span>
<span class="n">lstarmap</span> <span class="o">=</span> <span class="n">estarmap</span>


<div class="viewcode-block" id="maplen"><a class="viewcode-back" href="../../utool.html#utool.util_list.maplen">[docs]</a><span class="k">def</span> <span class="nf">maplen</span><span class="p">(</span><span class="n">iter_</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">iter_</span><span class="p">))</span></div>


<div class="viewcode-block" id="rebase_labels"><a class="viewcode-back" href="../../utool.html#utool.util_list.rebase_labels">[docs]</a><span class="k">def</span> <span class="nf">rebase_labels</span><span class="p">(</span><span class="n">label_list</span><span class="p">):</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">orig_to_new</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">label_list</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">orig_to_new</span><span class="p">:</span>
            <span class="n">orig_to_new</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="n">counter</span><span class="p">)</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">rebased_labels</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">orig_to_new</span><span class="p">,</span> <span class="n">label_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rebased_labels</span></div>


<div class="viewcode-block" id="replace_nones"><a class="viewcode-back" href="../../utool.html#utool.util_list.replace_nones">[docs]</a><span class="k">def</span> <span class="nf">replace_nones</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">repl</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively removes Nones in all lists and sublists and replaces them with</span>
<span class="sd">    the repl variable</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (list):</span>
<span class="sd">        repl (obj): replacement value</span>

<span class="sd">    Returns:</span>
<span class="sd">        list</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-replace_nones</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; # build test data</span>
<span class="sd">        &gt;&gt;&gt; list_ = [None, 0, 1, 2]</span>
<span class="sd">        &gt;&gt;&gt; repl = -1</span>
<span class="sd">        &gt;&gt;&gt; # execute function</span>
<span class="sd">        &gt;&gt;&gt; repl_list = replace_nones(list_, repl)</span>
<span class="sd">        &gt;&gt;&gt; # verify results</span>
<span class="sd">        &gt;&gt;&gt; result = str(repl_list)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [-1, 0, 1, 2]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">repl_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">repl</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="p">(</span><span class="n">replace_nones</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">item</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">repl_list</span></div>


<div class="viewcode-block" id="recursive_replace"><a class="viewcode-back" href="../../utool.html#utool.util_list.recursive_replace">[docs]</a><span class="k">def</span> <span class="nf">recursive_replace</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">repl</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively removes target in all lists and sublists and replaces them with</span>
<span class="sd">    the repl variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">repl_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">recursive_replace</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span>
        <span class="k">else</span> <span class="p">(</span><span class="n">repl</span> <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="n">target</span> <span class="k">else</span> <span class="n">item</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">repl_list</span></div>


<div class="viewcode-block" id="list_replace"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_replace">[docs]</a><span class="k">def</span> <span class="nf">list_replace</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">repl</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    alias</span>

<span class="sd">    Recursively removes target in all lists and sublists and replaces them with</span>
<span class="sd">    the repl variable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">recursive_replace</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span></div>


<div class="viewcode-block" id="alloc_lists"><a class="viewcode-back" href="../../utool.html#utool.util_list.alloc_lists">[docs]</a><span class="k">def</span> <span class="nf">alloc_lists</span><span class="p">(</span><span class="n">num_alloc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; allocates space for a ``list`` of lists &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_alloc</span><span class="p">)]</span></div>


<div class="viewcode-block" id="alloc_nones"><a class="viewcode-back" href="../../utool.html#utool.util_list.alloc_nones">[docs]</a><span class="k">def</span> <span class="nf">alloc_nones</span><span class="p">(</span><span class="n">num_alloc</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; allocates space for a ``list`` of Nones &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_alloc</span></div>
    <span class="c1"># return [None for _ in range(num_alloc)]</span>


<div class="viewcode-block" id="ensure_list_size"><a class="viewcode-back" href="../../utool.html#utool.util_list.ensure_list_size">[docs]</a><span class="k">def</span> <span class="nf">ensure_list_size</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">size_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Allocates more space if needbe.</span>

<span class="sd">    Ensures len(``list_``) == ``size_``.</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (list): ``list`` to extend</span>
<span class="sd">        size_ (int): amount to exent by</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lendiff</span> <span class="o">=</span> <span class="p">(</span><span class="n">size_</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">lendiff</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">extension</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lendiff</span><span class="p">)]</span>
        <span class="n">list_</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">extension</span><span class="p">)</span></div>


<span class="c1"># --- List Searching --- #</span>


<div class="viewcode-block" id="get_list_column_slice"><a class="viewcode-back" href="../../utool.html#utool.util_list.get_list_column_slice">[docs]</a><span class="k">def</span> <span class="nf">get_list_column_slice</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">util_iter</span><span class="o">.</span><span class="n">iget_list_column_slice</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">stride</span><span class="p">))</span></div>


<div class="viewcode-block" id="take_column"><a class="viewcode-back" href="../../utool.html#utool.util_list.take_column">[docs]</a><span class="k">def</span> <span class="nf">take_column</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">colx</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    accepts a list of (indexables) and returns a list of indexables</span>
<span class="sd">    can also return a list of list of indexables if colx is a list</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (list):  list of lists</span>
<span class="sd">        colx (int or list): index or key in each sublist get item</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: list of selected items</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-take_column</span>

<span class="sd">    Example0:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list_ = [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]</span>
<span class="sd">        &gt;&gt;&gt; colx = 0</span>
<span class="sd">        &gt;&gt;&gt; result = take_column(list_, colx)</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; result = ut.repr4(result, nl=False)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [&#39;a&#39;, &#39;c&#39;]</span>

<span class="sd">    Example1:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list_ = [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]</span>
<span class="sd">        &gt;&gt;&gt; colx = [1, 0]</span>
<span class="sd">        &gt;&gt;&gt; result = take_column(list_, colx)</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; result = ut.repr4(result, nl=False)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[&#39;b&#39;, &#39;a&#39;], [&#39;d&#39;, &#39;c&#39;]]</span>

<span class="sd">    Example2:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list_ = [{&#39;spam&#39;: &#39;EGGS&#39;, &#39;ham&#39;: &#39;SPAM&#39;}, {&#39;spam&#39;: &#39;JAM&#39;, &#39;ham&#39;: &#39;PRAM&#39;}]</span>
<span class="sd">        &gt;&gt;&gt; # colx can be a key or list of keys as well</span>
<span class="sd">        &gt;&gt;&gt; colx = [&#39;spam&#39;]</span>
<span class="sd">        &gt;&gt;&gt; result = take_column(list_, colx)</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; result = ut.repr4(result, nl=False)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[&#39;EGGS&#39;], [&#39;JAM&#39;]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># return list(util_iter.iget_list_column(list_, colx))</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">util_iter</span><span class="o">.</span><span class="n">itake_column</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">colx</span><span class="p">))</span></div>
    <span class="c1"># if isinstance(colx, list):</span>
    <span class="c1">#    # multi select</span>
    <span class="c1">#    return [[row[colx_] for colx_ in colx] for row in list_]</span>
    <span class="c1"># else:</span>
    <span class="c1">#    return [row[colx] for row in list_]</span>


<span class="n">get_list_column</span> <span class="o">=</span> <span class="n">take_column</span>
<span class="c1"># def get_list_row(list_, rowx):</span>
<span class="c1">#    return list_[rowx]</span>


<div class="viewcode-block" id="safeapply"><a class="viewcode-back" href="../../utool.html#utool.util_list.safeapply">[docs]</a><span class="k">def</span> <span class="nf">safeapply</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="safelen"><a class="viewcode-back" href="../../utool.html#utool.util_list.safelen">[docs]</a><span class="k">def</span> <span class="nf">safelen</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">safeapply</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">list_</span><span class="p">)</span></div>
    <span class="c1"># return None if list_ is None else len(list_)</span>


<div class="viewcode-block" id="safe_listget"><a class="viewcode-back" href="../../utool.html#utool.util_list.safe_listget">[docs]</a><span class="k">def</span> <span class="nf">safe_listget</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;?&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; depricate &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">index</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">default</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">list_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ret</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">default</span>
    <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="listclip"><a class="viewcode-back" href="../../utool.html#utool.util_list.listclip">[docs]</a><span class="k">def</span> <span class="nf">listclip</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">fromback</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DEPRICATE: use slices instead</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (list):</span>
<span class="sd">        num (int):</span>

<span class="sd">    Returns:</span>
<span class="sd">        sublist:</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-listclip</span>

<span class="sd">    Example1:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; # build test data</span>
<span class="sd">        &gt;&gt;&gt; list_ = [1, 2, 3, 4, 5]</span>
<span class="sd">        &gt;&gt;&gt; result_list = []</span>
<span class="sd">        &gt;&gt;&gt; # execute function</span>
<span class="sd">        &gt;&gt;&gt; num = 3</span>
<span class="sd">        &gt;&gt;&gt; result_list += [ut.listclip(list_, num)]</span>
<span class="sd">        &gt;&gt;&gt; num = 9</span>
<span class="sd">        &gt;&gt;&gt; result_list += [ut.listclip(list_, num)]</span>
<span class="sd">        &gt;&gt;&gt; # verify results</span>
<span class="sd">        &gt;&gt;&gt; result = ut.repr4(result_list)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [</span>
<span class="sd">            [1, 2, 3],</span>
<span class="sd">            [1, 2, 3, 4, 5],</span>
<span class="sd">        ]</span>

<span class="sd">    Example2:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; # build test data</span>
<span class="sd">        &gt;&gt;&gt; list_ = [1, 2, 3, 4, 5]</span>
<span class="sd">        &gt;&gt;&gt; result_list = []</span>
<span class="sd">        &gt;&gt;&gt; # execute function</span>
<span class="sd">        &gt;&gt;&gt; num = 3</span>
<span class="sd">        &gt;&gt;&gt; result = ut.listclip(list_, num, fromback=True)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [3, 4, 5]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">num_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">num_</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_</span><span class="p">),</span> <span class="n">num</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fromback</span><span class="p">:</span>
        <span class="n">sublist</span> <span class="o">=</span> <span class="n">list_</span><span class="p">[</span><span class="o">-</span><span class="n">num_</span><span class="p">:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sublist</span> <span class="o">=</span> <span class="n">list_</span><span class="p">[:</span><span class="n">num_</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">sublist</span></div>


<div class="viewcode-block" id="find_list_indexes"><a class="viewcode-back" href="../../utool.html#utool.util_list.find_list_indexes">[docs]</a><span class="k">def</span> <span class="nf">find_list_indexes</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        list_ (list): list of items to be searched</span>
<span class="sd">        items (list): list of items to find</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list_ = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">        &gt;&gt;&gt; items = [&#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;f&#39;]</span>
<span class="sd">        &gt;&gt;&gt; index_list = find_list_indexes(list_, items)</span>
<span class="sd">        &gt;&gt;&gt; result = (&#39;index_list = %r&#39; % (index_list,))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        index_list = [None, 2, 1, None]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">index_lookup</span> <span class="o">=</span> <span class="n">make_index_lookup</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span>
    <span class="n">index_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">index_lookup</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">]</span>
    <span class="c1"># index_list = [listfind(list_, item) for item in items]</span>
    <span class="k">return</span> <span class="n">index_list</span></div>


<div class="viewcode-block" id="listfind"><a class="viewcode-back" href="../../utool.html#utool.util_list.listfind">[docs]</a><span class="k">def</span> <span class="nf">listfind</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">tofind</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    get the position of item ``tofind`` in ``list_`` if it exists</span>
<span class="sd">    otherwise returns None</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (?):</span>
<span class="sd">        tofind (?):</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: index of ``tofind`` in ``list_``</span>

<span class="sd">    Example1:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list_ = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">        &gt;&gt;&gt; tofind = &#39;b&#39;</span>
<span class="sd">        &gt;&gt;&gt; result = listfind(list_, tofind)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">list_</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">tofind</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="search_list"><a class="viewcode-back" href="../../utool.html#utool.util_list.search_list">[docs]</a><span class="k">def</span> <span class="nf">search_list</span><span class="p">(</span><span class="n">text_list</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-search_list</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; text_list = [&#39;ham&#39;, &#39;jam&#39;, &#39;eggs&#39;, &#39;spam&#39;]</span>
<span class="sd">        &gt;&gt;&gt; pattern = &#39;.am&#39;</span>
<span class="sd">        &gt;&gt;&gt; flags = 0</span>
<span class="sd">        &gt;&gt;&gt; (valid_index_list, valid_match_list) = ut.search_list(text_list, pattern, flags)</span>
<span class="sd">        &gt;&gt;&gt; result = str(valid_index_list)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [0, 1, 3]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">re</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">match_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">flags</span><span class="p">)</span> <span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">text_list</span><span class="p">]</span>
    <span class="n">valid_index_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">match</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">match_list</span><span class="p">)</span> <span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="p">]</span>
    <span class="n">valid_match_list</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">match_list</span><span class="p">,</span> <span class="n">valid_index_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">valid_index_list</span><span class="p">,</span> <span class="n">valid_match_list</span></div>


<span class="c1"># --- List Modification --- #</span>


<div class="viewcode-block" id="multi_replace"><a class="viewcode-back" href="../../utool.html#utool.util_list.multi_replace">[docs]</a><span class="k">def</span> <span class="nf">multi_replace</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">search_list</span><span class="o">=</span><span class="p">[],</span> <span class="n">repl_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Does a string replace with a list of search and replacements</span>

<span class="sd">    TODO: rename</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">repl_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">search_list</span><span class="p">)</span> <span class="k">if</span> <span class="n">repl_list</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">repl_list</span>
    <span class="k">for</span> <span class="n">ser</span><span class="p">,</span> <span class="n">repl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">search_list</span><span class="p">,</span> <span class="n">repl_list</span><span class="p">):</span>
        <span class="n">instr</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">ser</span><span class="p">,</span> <span class="n">repl</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">instr</span></div>


<div class="viewcode-block" id="flatten"><a class="viewcode-back" href="../../utool.html#utool.util_list.flatten">[docs]</a><span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        list_ (list): list of lists</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: flat list</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-flatten</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; list_ = [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]]</span>
<span class="sd">        &gt;&gt;&gt; unflat_list2 = flatten(list_)</span>
<span class="sd">        &gt;&gt;&gt; result = ut.repr4(unflat_list2, nl=False)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">util_iter</span><span class="o">.</span><span class="n">iflatten</span><span class="p">(</span><span class="n">list_</span><span class="p">))</span></div>


<div class="viewcode-block" id="invertible_flatten1"><a class="viewcode-back" href="../../utool.html#utool.util_list.invertible_flatten1">[docs]</a><span class="k">def</span> <span class="nf">invertible_flatten1</span><span class="p">(</span><span class="n">unflat_list</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flattens `unflat_list` but remember how to reconstruct the `unflat_list`</span>
<span class="sd">    Returns `flat_list` and the `reverse_list` with indexes into the</span>
<span class="sd">    `flat_list`</span>

<span class="sd">    Args:</span>
<span class="sd">        unflat_list (list): list of nested lists that we will flatten.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple : (flat_list, reverse_list)</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --exec-invertible_flatten1 --show</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; unflat_list = [[1, 2, 3], [4, 5], [6, 6]]</span>
<span class="sd">        &gt;&gt;&gt; flat_list, reverse_list = invertible_flatten1(unflat_list)</span>
<span class="sd">        &gt;&gt;&gt; result = (&#39;flat_list = %s\n&#39; % (ut.repr2(flat_list),))</span>
<span class="sd">        &gt;&gt;&gt; result += (&#39;reverse_list = %s&#39; % (ut.repr2(reverse_list),))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        flat_list = [1, 2, 3, 4, 5, 6, 6]</span>
<span class="sd">        reverse_list = [[0, 1, 2], [3, 4], [5, 6]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nextnum</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">next</span><span class="p">,</span> <span class="n">itertools</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
    <span class="c1"># Build an unflat list of flat indexes</span>
    <span class="n">reverse_list</span> <span class="o">=</span> <span class="p">[[</span><span class="n">nextnum</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tup</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">unflat_list</span><span class="p">]</span>
    <span class="n">flat_list</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">unflat_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flat_list</span><span class="p">,</span> <span class="n">reverse_list</span></div>


<div class="viewcode-block" id="unflatten1"><a class="viewcode-back" href="../../utool.html#utool.util_list.unflatten1">[docs]</a><span class="k">def</span> <span class="nf">unflatten1</span><span class="p">(</span><span class="n">flat_list</span><span class="p">,</span> <span class="n">reverse_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Rebuilds unflat list from invertible_flatten1</span>

<span class="sd">    Args:</span>
<span class="sd">        flat_list (list): the flattened list</span>
<span class="sd">        reverse_list (list): the list which undoes flattenting</span>

<span class="sd">    Returns:</span>
<span class="sd">        unflat_list2: original nested list</span>


<span class="sd">    SeeAlso:</span>
<span class="sd">        invertible_flatten1</span>
<span class="sd">        invertible_flatten2</span>
<span class="sd">        unflatten2</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unflat_list2</span> <span class="o">=</span> <span class="p">[[</span><span class="n">flat_list</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">tup</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">reverse_list</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">unflat_list2</span></div>


<div class="viewcode-block" id="accumulate"><a class="viewcode-back" href="../../utool.html#utool.util_list.accumulate">[docs]</a><span class="k">def</span> <span class="nf">accumulate</span><span class="p">(</span><span class="n">iterator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Notice:</span>
<span class="sd">        use itertools.accumulate in python &gt; 3.2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">iterator</span><span class="p">:</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">item</span>
        <span class="k">yield</span> <span class="n">total</span></div>


<div class="viewcode-block" id="total_flatten"><a class="viewcode-back" href="../../utool.html#utool.util_list.total_flatten">[docs]</a><span class="k">def</span> <span class="nf">total_flatten</span><span class="p">(</span><span class="n">unflat_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    unflat_list = [1, 2, [3, 4], [5, [9]]]</span>
<span class="sd">    Args:</span>
<span class="sd">        unflat_list (list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: flat_list</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --exec-total_flatten --show</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; unflat_list = [[[1, 2, 3], 4, 5], 9, [2, 3], [1, [2, 3, 4]], 1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; flat_list = total_flatten(unflat_list)</span>
<span class="sd">        &gt;&gt;&gt; result = (&#39;flat_list = %s&#39; % (ut.repr2(flat_list),))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">next_list</span> <span class="o">=</span> <span class="n">unflat_list</span>
    <span class="n">scalar_flags</span> <span class="o">=</span> <span class="p">[</span><span class="ow">not</span> <span class="n">ut</span><span class="o">.</span><span class="n">isiterable</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">next_list</span><span class="p">]</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">scalar_flags</span><span class="p">):</span>
        <span class="n">unflatenized</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">if</span> <span class="n">flag</span> <span class="k">else</span> <span class="n">item</span> <span class="k">for</span> <span class="n">flag</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">scalar_flags</span><span class="p">,</span> <span class="n">next_list</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">flatter_list</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">unflatenized</span><span class="p">)</span>
        <span class="n">next_list</span> <span class="o">=</span> <span class="n">flatter_list</span>
        <span class="n">scalar_flags</span> <span class="o">=</span> <span class="p">[</span><span class="ow">not</span> <span class="n">ut</span><span class="o">.</span><span class="n">isiterable</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">next_list</span><span class="p">]</span>
    <span class="n">flat_list</span> <span class="o">=</span> <span class="n">next_list</span>
    <span class="k">return</span> <span class="n">flat_list</span></div>


<div class="viewcode-block" id="invertible_total_flatten"><a class="viewcode-back" href="../../utool.html#utool.util_list.invertible_total_flatten">[docs]</a><span class="k">def</span> <span class="nf">invertible_total_flatten</span><span class="p">(</span><span class="n">unflat_list</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        unflat_list (list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: (flat_list, invert_levels)</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --exec-invertible_total_flatten --show</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; unflat_list = [0, [[1, 2, 3], 4, 5], 9, [2, 3], [1, [2, 3, 4]], 1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;unflat_list = %r&#39; % (unflat_list,))</span>
<span class="sd">        &gt;&gt;&gt; (flat_list, invert_levels) = invertible_total_flatten(unflat_list)</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;flat_list = %r&#39; % (flat_list,))</span>
<span class="sd">        &gt;&gt;&gt; unflat_list2 = total_unflatten(flat_list, invert_levels)</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;unflat_list2 = %r&#39; % (unflat_list2,))</span>
<span class="sd">        &gt;&gt;&gt; assert unflat_list2 == unflat_list</span>
<span class="sd">        &gt;&gt;&gt; assert ut.depth_profile(flat_list) == 16</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">next_list</span> <span class="o">=</span> <span class="n">unflat_list</span>
    <span class="n">scalar_flags</span> <span class="o">=</span> <span class="p">[</span><span class="ow">not</span> <span class="n">ut</span><span class="o">.</span><span class="n">isiterable</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">next_list</span><span class="p">]</span>
    <span class="n">invert_stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># print(&#39;unflat_list = %r&#39; % (unflat_list,))</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">scalar_flags</span><span class="p">):</span>
        <span class="n">unflattenized</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">if</span> <span class="n">flag</span> <span class="k">else</span> <span class="n">item</span> <span class="k">for</span> <span class="n">flag</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">scalar_flags</span><span class="p">,</span> <span class="n">next_list</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">flatter_list</span><span class="p">,</span> <span class="n">invert_part</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">invertible_flatten1</span><span class="p">(</span><span class="n">unflattenized</span><span class="p">)</span>
        <span class="c1"># print(&#39;flatter_list = %r&#39; % (flatter_list,))</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">ut</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">scalar_flags</span><span class="p">):</span>
            <span class="n">invert_part</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">invert_part</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">invert_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">invert_part</span><span class="p">)</span>
        <span class="n">next_list</span> <span class="o">=</span> <span class="n">flatter_list</span>
        <span class="n">scalar_flags</span> <span class="o">=</span> <span class="p">[</span><span class="ow">not</span> <span class="n">ut</span><span class="o">.</span><span class="n">isiterable</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">next_list</span><span class="p">]</span>
    <span class="c1"># invert_part = [None] * len(scalar_flags)</span>
    <span class="c1"># invert_stack.append(invert_part)</span>
    <span class="n">invert_levels</span> <span class="o">=</span> <span class="n">invert_stack</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">flat_list</span> <span class="o">=</span> <span class="n">next_list</span>
    <span class="k">return</span> <span class="n">flat_list</span><span class="p">,</span> <span class="n">invert_levels</span></div>


<div class="viewcode-block" id="total_unflatten"><a class="viewcode-back" href="../../utool.html#utool.util_list.total_unflatten">[docs]</a><span class="k">def</span> <span class="nf">total_unflatten</span><span class="p">(</span><span class="n">flat_list</span><span class="p">,</span> <span class="n">invert_levels</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">less_flat_list</span> <span class="o">=</span> <span class="n">flat_list</span>
    <span class="c1"># print(&#39;less_flat_list = %r&#39; % (less_flat_list,))</span>
    <span class="k">for</span> <span class="n">lx</span><span class="p">,</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">invert_levels</span><span class="p">):</span>
        <span class="n">needs_unflatten</span> <span class="o">=</span> <span class="p">[</span><span class="n">ut</span><span class="o">.</span><span class="n">isiterable</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">level</span><span class="p">]</span>
        <span class="n">is_alreadyflat</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">not_list</span><span class="p">(</span><span class="n">needs_unflatten</span><span class="p">)</span>
        <span class="n">needs_unflatxs</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">needs_unflatten</span><span class="p">)</span>
        <span class="n">already_flatxs</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">is_alreadyflat</span><span class="p">)</span>
        <span class="n">invertinfo</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">needs_unflatten</span><span class="p">)</span>
        <span class="n">unflat_part</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">unflatten1</span><span class="p">(</span><span class="n">less_flat_list</span><span class="p">,</span> <span class="n">invertinfo</span><span class="p">)</span>

        <span class="n">flat_sortx</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">already_flatxs</span><span class="p">)</span>
        <span class="n">flat_part</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">less_flat_list</span><span class="p">,</span> <span class="n">flat_sortx</span><span class="p">)</span>
        <span class="n">maxsize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">already_flatxs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">needs_unflatxs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c1"># (len(invertinfo) + sum(is_alreadyflat) + 1)</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="p">[</span><span class="n">flat_part</span><span class="p">,</span> <span class="n">unflat_part</span><span class="p">]</span>
        <span class="n">groupxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">already_flatxs</span><span class="p">,</span> <span class="n">needs_unflatxs</span><span class="p">]</span>
        <span class="n">less_flat_list_</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">ungroup</span><span class="p">(</span><span class="n">groups</span><span class="p">,</span> <span class="n">groupxs</span><span class="p">,</span> <span class="n">maxsize</span><span class="p">)</span>
        <span class="n">less_flat_list</span> <span class="o">=</span> <span class="n">less_flat_list_</span>
    <span class="n">unflat_list</span> <span class="o">=</span> <span class="n">less_flat_list</span>
    <span class="k">return</span> <span class="n">unflat_list</span></div>


<div class="viewcode-block" id="invertible_flatten2"><a class="viewcode-back" href="../../utool.html#utool.util_list.invertible_flatten2">[docs]</a><span class="k">def</span> <span class="nf">invertible_flatten2</span><span class="p">(</span><span class="n">unflat_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An alternative to invertible_flatten1 which uses cumsum</span>

<span class="sd">    Flattens ``list`` but remember how to reconstruct the unflat ``list``</span>
<span class="sd">    Returns flat ``list`` and the unflat ``list`` with indexes into the flat</span>
<span class="sd">    ``list``</span>

<span class="sd">    Args:</span>
<span class="sd">        unflat_list (list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: flat_list, cumlen_list</span>

<span class="sd">    SeeAlso:</span>
<span class="sd">        invertible_flatten1</span>
<span class="sd">        unflatten1</span>
<span class="sd">        unflatten2</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool</span>
<span class="sd">        &gt;&gt;&gt; utool.util_list</span>
<span class="sd">        &gt;&gt;&gt; unflat_list = [[5], [2, 3, 12, 3, 3], [9], [13, 3], [5]]</span>
<span class="sd">        &gt;&gt;&gt; flat_list, cumlen_list = invertible_flatten2(unflat_list)</span>
<span class="sd">        &gt;&gt;&gt; unflat_list2 = unflatten2(flat_list, cumlen_list)</span>
<span class="sd">        &gt;&gt;&gt; assert unflat_list2 == unflat_list</span>
<span class="sd">        &gt;&gt;&gt; result = ((flat_list, cumlen_list))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        ([5, 2, 3, 12, 3, 3, 9, 13, 3, 5], [1, 6, 7, 9, 10])</span>

<span class="sd">    TODO: This flatten is faster fix it to be used everywhere</span>

<span class="sd">    Timeit:</span>
<span class="sd">        unflat_list = [[random.random() for _ in range(int(random.random() * 1000))] for __ in range(200)]</span>
<span class="sd">        unflat_arrs = list(map(np.array, unflat_list))</span>

<span class="sd">        %timeit invertible_flatten2(unflat_list)</span>
<span class="sd">        %timeit invertible_flatten2_numpy(unflat_list)</span>
<span class="sd">        %timeit invertible_flatten2_numpy(unflat_arrs)</span>

<span class="sd">    Timeits:</span>
<span class="sd">        import utool</span>
<span class="sd">        unflat_list = aids_list1</span>
<span class="sd">        flat_aids1, reverse_list = utool.invertible_flatten1(unflat_list)</span>
<span class="sd">        flat_aids2, cumlen_list = utool.invertible_flatten2(unflat_list)</span>
<span class="sd">        unflat_list1 = utool.unflatten1(flat_aids1, reverse_list)</span>
<span class="sd">        unflat_list2 = utool.unflatten2(flat_aids2, cumlen_list)</span>
<span class="sd">        assert list(map(list, unflat_list1)) == unflat_list2</span>
<span class="sd">        print(utool.get_object_size_str(unflat_list,  &#39;unflat_list  &#39;))</span>
<span class="sd">        print(utool.get_object_size_str(flat_aids1,   &#39;flat_aids1   &#39;))</span>
<span class="sd">        print(utool.get_object_size_str(flat_aids2,   &#39;flat_aids2   &#39;))</span>
<span class="sd">        print(utool.get_object_size_str(reverse_list, &#39;reverse_list &#39;))</span>
<span class="sd">        print(utool.get_object_size_str(cumlen_list,  &#39;cumlen_list  &#39;))</span>
<span class="sd">        print(utool.get_object_size_str(unflat_list1, &#39;unflat_list1 &#39;))</span>
<span class="sd">        print(utool.get_object_size_str(unflat_list2, &#39;unflat_list2 &#39;))</span>
<span class="sd">        print(&#39;Timings 1:)</span>
<span class="sd">        %timeit utool.invertible_flatten1(unflat_list)</span>
<span class="sd">        %timeit utool.unflatten1(flat_aids1, reverse_list)</span>
<span class="sd">        print(&#39;Timings 2:)</span>
<span class="sd">        %timeit utool.invertible_flatten2(unflat_list)</span>
<span class="sd">        %timeit utool.unflatten2(flat_aids2, cumlen_list)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sublen_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">unflat_list</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">util_type</span><span class="o">.</span><span class="n">HAVE_NUMPY</span><span class="p">:</span>
        <span class="n">cumlen_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">sublen_list</span><span class="p">)</span>
        <span class="c1"># Build an unflat list of flat indexes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cumlen_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">accumulate</span><span class="p">(</span><span class="n">sublen_list</span><span class="p">))</span>
    <span class="n">flat_list</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">unflat_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flat_list</span><span class="p">,</span> <span class="n">cumlen_list</span></div>


<div class="viewcode-block" id="invertible_flatten2_numpy"><a class="viewcode-back" href="../../utool.html#utool.util_list.invertible_flatten2_numpy">[docs]</a><span class="k">def</span> <span class="nf">invertible_flatten2_numpy</span><span class="p">(</span><span class="n">unflat_arrs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; more numpy version</span>

<span class="sd">    TODO: move to vtool</span>

<span class="sd">    Args:</span>
<span class="sd">        unflat_arrs (list):  list of ndarrays</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: (flat_list, cumlen_list)</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-invertible_flatten2_numpy</span>

<span class="sd">    Ignore:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTET</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; unflat_arrs = [np.array([1, 2, 1]), np.array([5, 9]), np.array([4])]</span>
<span class="sd">        &gt;&gt;&gt; (flat_list, cumlen_list) = invertible_flatten2_numpy(unflat_arrs)</span>
<span class="sd">        &gt;&gt;&gt; result = str((flat_list, cumlen_list))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        (array([1, 2, 1, 5, 9, 4]), array([3, 5, 6]))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cumlen_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">unflat_arrs</span><span class="p">])</span>
    <span class="n">flat_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">unflat_arrs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flat_list</span><span class="p">,</span> <span class="n">cumlen_list</span></div>


<div class="viewcode-block" id="unflatten2"><a class="viewcode-back" href="../../utool.html#utool.util_list.unflatten2">[docs]</a><span class="k">def</span> <span class="nf">unflatten2</span><span class="p">(</span><span class="n">flat_list</span><span class="p">,</span> <span class="n">cumlen_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Rebuilds unflat list from invertible_flatten1</span>

<span class="sd">    Args:</span>
<span class="sd">        flat_list (list): the flattened list</span>
<span class="sd">        cumlen_list (list): the list which undoes flattenting</span>

<span class="sd">    Returns:</span>
<span class="sd">        unflat_list2: original nested list</span>

<span class="sd">    SeeAlso:</span>
<span class="sd">        invertible_flatten1</span>
<span class="sd">        invertible_flatten2</span>
<span class="sd">        unflatten2</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool</span>
<span class="sd">        &gt;&gt;&gt; utool.util_list</span>
<span class="sd">        &gt;&gt;&gt; flat_list = [5, 2, 3, 12, 3, 3, 9, 13, 3, 5]</span>
<span class="sd">        &gt;&gt;&gt; cumlen_list = [ 1,  6,  7,  9, 10]</span>
<span class="sd">        &gt;&gt;&gt; unflat_list2 = unflatten2(flat_list, cumlen_list)</span>
<span class="sd">        &gt;&gt;&gt; result = (unflat_list2)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[5], [2, 3, 12, 3, 3], [9], [13, 3], [5]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">unflat_list2</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">flat_list</span><span class="p">[</span><span class="n">low</span><span class="p">:</span><span class="n">high</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">cumlen_list</span><span class="p">),</span> <span class="n">cumlen_list</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">unflat_list2</span></div>


<div class="viewcode-block" id="unflat_unique_rowid_map"><a class="viewcode-back" href="../../utool.html#utool.util_list.unflat_unique_rowid_map">[docs]</a><span class="k">def</span> <span class="nf">unflat_unique_rowid_map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">unflat_rowids</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    performs only one call to the underlying func with unique rowids the func</span>
<span class="sd">    must be some lookup function</span>

<span class="sd">    TODO: move this to a better place.</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-unflat_unique_rowid_map:0</span>
<span class="sd">        python -m utool.util_list --test-unflat_unique_rowid_map:1</span>

<span class="sd">    Ignore:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; kwargs = {}</span>
<span class="sd">        &gt;&gt;&gt; unflat_rowids = [[1, 2, 3], [2, 5], [1], []]</span>
<span class="sd">        &gt;&gt;&gt; num_calls0 = [0]</span>
<span class="sd">        &gt;&gt;&gt; num_input0 = [0]</span>
<span class="sd">        &gt;&gt;&gt; def func0(rowids, num_calls0=num_calls0, num_input0=num_input0):</span>
<span class="sd">        ...     num_calls0[0] += 1</span>
<span class="sd">        ...     num_input0[0] += len(rowids)</span>
<span class="sd">        ...     return [rowid + 10 for rowid in rowids]</span>
<span class="sd">        &gt;&gt;&gt; func = func0</span>
<span class="sd">        &gt;&gt;&gt; unflat_vals = unflat_unique_rowid_map(func, unflat_rowids, **kwargs)</span>
<span class="sd">        &gt;&gt;&gt; result = [arr.tolist() for arr in unflat_vals]</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_eq(num_calls0[0], 1)</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_eq(num_input0[0], 4)</span>
<span class="sd">        [[11, 12, 13], [12, 15], [11], []]</span>

<span class="sd">    Ignore:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; kwargs = {}</span>
<span class="sd">        &gt;&gt;&gt; unflat_rowids = [[1, 2, 3], [2, 5], [1], []]</span>
<span class="sd">        &gt;&gt;&gt; num_calls1 = [0]</span>
<span class="sd">        &gt;&gt;&gt; num_input1 = [0]</span>
<span class="sd">        &gt;&gt;&gt; def func1(rowids, num_calls1=num_calls1, num_input1=num_input1, np=np):</span>
<span class="sd">        ...     num_calls1[0] += 1</span>
<span class="sd">        ...     num_input1[0] += len(rowids)</span>
<span class="sd">        ...     return [np.array([rowid + 10, rowid, 3]) for rowid in rowids]</span>
<span class="sd">        &gt;&gt;&gt; func = func1</span>
<span class="sd">        &gt;&gt;&gt; unflat_vals = unflat_unique_rowid_map(func, unflat_rowids, **kwargs)</span>
<span class="sd">        &gt;&gt;&gt; result = [arr.tolist() for arr in unflat_vals]</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_eq(num_calls1[0], 1)</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_eq(num_input1[0], 4)</span>
<span class="sd">        [[[11, 1, 3], [12, 2, 3], [13, 3, 3]], [[12, 2, 3], [15, 5, 3]], [[11, 1, 3]], []]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="c1"># First flatten the list, and remember the original dimensions</span>
    <span class="n">flat_rowids</span><span class="p">,</span> <span class="n">reverse_list</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">invertible_flatten2</span><span class="p">(</span><span class="n">unflat_rowids</span><span class="p">)</span>
    <span class="c1"># Then make the input unique</span>
    <span class="n">flat_rowids_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flat_rowids</span><span class="p">)</span>
    <span class="n">unique_flat_rowids</span><span class="p">,</span> <span class="n">inverse_unique</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">flat_rowids_arr</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1"># Then preform the lookup / implicit mapping</span>
    <span class="n">unique_flat_vals</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">unique_flat_rowids</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># Then broadcast unique values back to original flat positions</span>
    <span class="n">flat_vals_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">unique_flat_vals</span><span class="p">)[</span><span class="n">inverse_unique</span><span class="p">]</span>
    <span class="c1"># flat_vals_ = np.array(unique_flat_vals).take(inverse_unique, axis=0)</span>
    <span class="n">output_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">flat_rowids_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">flat_vals_</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="n">flat_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flat_vals_</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">output_shape</span><span class="p">)</span>
    <span class="c1"># Then _unflatten the results to the original input dimensions</span>
    <span class="n">unflat_vals</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">unflatten2</span><span class="p">(</span><span class="n">flat_vals</span><span class="p">,</span> <span class="n">reverse_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unflat_vals</span></div>


<div class="viewcode-block" id="unpack_iterables"><a class="viewcode-back" href="../../utool.html#utool.util_list.unpack_iterables">[docs]</a><span class="k">def</span> <span class="nf">unpack_iterables</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="k">if</span> <span class="n">ut</span><span class="o">.</span><span class="n">isiterable</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">new_item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_</span> <span class="k">for</span> <span class="n">new_item</span> <span class="ow">in</span> <span class="n">unpack_iterables</span><span class="p">(</span><span class="n">item</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">list_</span><span class="p">]</span></div>


<div class="viewcode-block" id="safe_slice"><a class="viewcode-back" href="../../utool.html#utool.util_list.safe_slice">[docs]</a><span class="k">def</span> <span class="nf">safe_slice</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; safe_slice(list_, [start], stop, [end], [step])</span>
<span class="sd">        Slices list and truncates if out of bounds</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">len_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="n">len_</span><span class="p">:</span>
        <span class="n">stop</span> <span class="o">=</span> <span class="n">len_</span>
    <span class="k">return</span> <span class="n">list_</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)]</span></div>


<span class="c1"># --- List Queries --- #</span>


<div class="viewcode-block" id="allsame"><a class="viewcode-back" href="../../utool.html#utool.util_list.allsame">[docs]</a><span class="k">def</span> <span class="nf">allsame</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    checks to see if list is equal everywhere</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if all items in the list are equal</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="n">first_item</span> <span class="o">=</span> <span class="n">list_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">list_all_eq_to</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">first_item</span><span class="p">,</span> <span class="n">strict</span><span class="p">)</span></div>


<div class="viewcode-block" id="list_all_eq_to"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_all_eq_to">[docs]</a><span class="k">def</span> <span class="nf">list_all_eq_to</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    checks to see if list is equal everywhere to a value</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (list):</span>
<span class="sd">        val : value to check against</span>

<span class="sd">    Returns:</span>
<span class="sd">        True if all items in the list are equal to val</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">util_type</span><span class="o">.</span><span class="n">HAVE_NUMPY</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">item</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_</span><span class="p">])</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># FUTURE WARNING</span>
        <span class="c1"># FutureWarning: comparison to `None` will result in an elementwise object comparison in the future.</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="ne">FutureWarning</span><span class="p">)</span>
            <span class="n">flags</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="o">==</span> <span class="n">val</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">(</span>
                <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="s1">&#39;__array__&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">flag</span> <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">flags</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="c1"># return all([item == val for item in list_])</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">strict</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">all</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="nb">repr</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span></div>


<div class="viewcode-block" id="get_dirty_items"><a class="viewcode-back" href="../../utool.html#utool.util_list.get_dirty_items">[docs]</a><span class="k">def</span> <span class="nf">get_dirty_items</span><span class="p">(</span><span class="n">item_list</span><span class="p">,</span> <span class="n">flag_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns each item in item_list where not flag in flag_list</span>

<span class="sd">    Args:</span>
<span class="sd">        item_list (list):</span>
<span class="sd">        flag_list (list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        dirty_items</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">item_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">flag_list</span><span class="p">)</span>
    <span class="n">dirty_items</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">flag</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">item_list</span><span class="p">,</span> <span class="n">flag_list</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">]</span>
    <span class="c1"># print(&#39;num_dirty_items = %r&#39; % len(dirty_items))</span>
    <span class="c1"># print(&#39;item_list = %r&#39; % (item_list,))</span>
    <span class="c1"># print(&#39;flag_list = %r&#39; % (flag_list,))</span>
    <span class="k">return</span> <span class="n">dirty_items</span></div>


<div class="viewcode-block" id="compress"><a class="viewcode-back" href="../../utool.html#utool.util_list.compress">[docs]</a><span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="n">item_list</span><span class="p">,</span> <span class="n">flag_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    like np.compress but for lists</span>

<span class="sd">    Returns items in item list where the corresponding item in flag list is</span>
<span class="sd">    True</span>

<span class="sd">    Args:</span>
<span class="sd">        item_list (list): list of items to mask</span>
<span class="sd">        flag_list (list): list of booleans used as a mask</span>

<span class="sd">    Returns:</span>
<span class="sd">        list : filtered_items - masked items</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">item_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">flag_list</span><span class="p">),</span> <span class="p">(</span>
        <span class="s1">&#39;lists should correspond. len(item_list)=</span><span class="si">%r</span><span class="s1"> len(flag_list)=</span><span class="si">%r</span><span class="s1">&#39;</span>
        <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item_list</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">flag_list</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">filtered_items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">util_iter</span><span class="o">.</span><span class="n">iter_compress</span><span class="p">(</span><span class="n">item_list</span><span class="p">,</span> <span class="n">flag_list</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">filtered_items</span></div>


<div class="viewcode-block" id="zipflat"><a class="viewcode-back" href="../../utool.html#utool.util_list.zipflat">[docs]</a><span class="k">def</span> <span class="nf">zipflat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">flatten</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)]</span></div>


<div class="viewcode-block" id="ziptake"><a class="viewcode-back" href="../../utool.html#utool.util_list.ziptake">[docs]</a><span class="k">def</span> <span class="nf">ziptake</span><span class="p">(</span><span class="n">items_list</span><span class="p">,</span> <span class="n">indexes_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SeeAlso:</span>
<span class="sd">        vt.ziptake</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="n">take</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">index_list</span><span class="p">)</span> <span class="k">for</span> <span class="n">list_</span><span class="p">,</span> <span class="n">index_list</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">items_list</span><span class="p">,</span> <span class="n">indexes_list</span><span class="p">)</span>
    <span class="p">]</span></div>


<div class="viewcode-block" id="zipcompress"><a class="viewcode-back" href="../../utool.html#utool.util_list.zipcompress">[docs]</a><span class="k">def</span> <span class="nf">zipcompress</span><span class="p">(</span><span class="n">items_list</span><span class="p">,</span> <span class="n">flags_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SeeAlso:</span>
<span class="sd">        vt.zipcompress</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">compress</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="k">for</span> <span class="n">list_</span><span class="p">,</span> <span class="n">flags</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">items_list</span><span class="p">,</span> <span class="n">flags_list</span><span class="p">)]</span></div>


<div class="viewcode-block" id="list_zipflatten"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_zipflatten">[docs]</a><span class="k">def</span> <span class="nf">list_zipflatten</span><span class="p">(</span><span class="o">*</span><span class="n">items_lists</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">flatten</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="k">for</span> <span class="n">items</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">items_lists</span><span class="p">)]</span></div>


<div class="viewcode-block" id="list_compresstake"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_compresstake">[docs]</a><span class="k">def</span> <span class="nf">list_compresstake</span><span class="p">(</span><span class="n">items_list</span><span class="p">,</span> <span class="n">flags_list</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">compress</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span> <span class="k">for</span> <span class="n">list_</span><span class="p">,</span> <span class="n">flags</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">items_list</span><span class="p">,</span> <span class="n">flags_list</span><span class="p">)]</span></div>


<div class="viewcode-block" id="filter_items"><a class="viewcode-back" href="../../utool.html#utool.util_list.filter_items">[docs]</a><span class="k">def</span> <span class="nf">filter_items</span><span class="p">(</span><span class="n">item_list</span><span class="p">,</span> <span class="n">flag_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns items in item list where the corresponding item in flag list is True</span>

<span class="sd">    Args:</span>
<span class="sd">        item_list (list):</span>
<span class="sd">        flag_list (list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        filtered_items</span>

<span class="sd">    SeeAlso:</span>
<span class="sd">        util_iter.iter_compress</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">compress</span><span class="p">(</span><span class="n">item_list</span><span class="p">,</span> <span class="n">flag_list</span><span class="p">)</span></div>


<div class="viewcode-block" id="filterfalse_items"><a class="viewcode-back" href="../../utool.html#utool.util_list.filterfalse_items">[docs]</a><span class="k">def</span> <span class="nf">filterfalse_items</span><span class="p">(</span><span class="n">item_list</span><span class="p">,</span> <span class="n">flag_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns items in item list where the corresponding item in flag list is true</span>

<span class="sd">    Args:</span>
<span class="sd">        item_list (list): list of items</span>
<span class="sd">        flag_list (list): list of truthy values</span>

<span class="sd">    Returns:</span>
<span class="sd">        filtered_items : items where the corresponding flag was truthy</span>

<span class="sd">    SeeAlso:</span>
<span class="sd">        util_iter.ifilterfalse_items</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">item_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">flag_list</span><span class="p">)</span>
    <span class="n">filtered_items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">util_iter</span><span class="o">.</span><span class="n">ifilterfalse_items</span><span class="p">(</span><span class="n">item_list</span><span class="p">,</span> <span class="n">flag_list</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">filtered_items</span></div>


<div class="viewcode-block" id="filter_Nones"><a class="viewcode-back" href="../../utool.html#utool.util_list.filter_Nones">[docs]</a><span class="k">def</span> <span class="nf">filter_Nones</span><span class="p">(</span><span class="n">item_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes any nones from the list</span>

<span class="sd">    Args:</span>
<span class="sd">        item_list (list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        sublist which does not contain Nones</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">util_iter</span><span class="o">.</span><span class="n">ifilter_Nones</span><span class="p">(</span><span class="n">item_list</span><span class="p">))</span></div>


<span class="c1"># --- List combinations --- #</span>


<div class="viewcode-block" id="isect"><a class="viewcode-back" href="../../utool.html#utool.util_list.isect">[docs]</a><span class="k">def</span> <span class="nf">isect</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns list1 elements that are also in list2. preserves order of list1</span>

<span class="sd">    intersect_ordered</span>

<span class="sd">    Args:</span>
<span class="sd">        list1 (list):</span>
<span class="sd">        list2 (list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: new_list</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list1 = [&#39;featweight_rowid&#39;, &#39;feature_rowid&#39;, &#39;config_rowid&#39;, &#39;featweight_forground_weight&#39;]</span>
<span class="sd">        &gt;&gt;&gt; list2 = [u&#39;featweight_rowid&#39;]</span>
<span class="sd">        &gt;&gt;&gt; result = intersect_ordered(list1, list2)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [&#39;featweight_rowid&#39;]</span>

<span class="sd">    Timeit:</span>
<span class="sd">        def timeit_func(func, *args):</span>
<span class="sd">            niter = 10</span>
<span class="sd">            times = []</span>
<span class="sd">            for count in range(niter):</span>
<span class="sd">                with ut.Timer(verbose=False) as t:</span>
<span class="sd">                    _ = func(*args)</span>
<span class="sd">                times.append(t.ellapsed)</span>
<span class="sd">            return sum(times) / niter</span>

<span class="sd">        grid = {</span>
<span class="sd">            &#39;size1&#39;: [1000, 5000, 10000, 50000],</span>
<span class="sd">            &#39;size2&#39;: [1000, 5000, 10000, 50000],</span>
<span class="sd">            #&#39;overlap&#39;: [0, 1],</span>
<span class="sd">        }</span>
<span class="sd">        data = []</span>
<span class="sd">        for kw in ut.all_dict_combinations(grid):</span>
<span class="sd">            pool = np.arange(kw[&#39;size1&#39;] * 2)</span>
<span class="sd">            size2 = size1 = kw[&#39;size1&#39;]</span>
<span class="sd">            size2 = kw[&#39;size2&#39;]</span>
<span class="sd">            list1 = (np.random.rand(size1) * size1).astype(np.int32).tolist()</span>
<span class="sd">            list1 = ut.random_sample(pool, size1).tolist()</span>
<span class="sd">            list2 = ut.random_sample(pool, size2).tolist()</span>
<span class="sd">            list1 = set(list1)</span>
<span class="sd">            list2 = set(list2)</span>
<span class="sd">            kw[&#39;ut&#39;] = timeit_func(ut.isect, list1, list2)</span>
<span class="sd">            #kw[&#39;np1&#39;] = timeit_func(np.intersect1d, list1, list2)</span>
<span class="sd">            #kw[&#39;py1&#39;] = timeit_func(lambda a, b: set.intersection(set(a), set(b)), list1, list2)</span>
<span class="sd">            kw[&#39;py2&#39;] = timeit_func(lambda a, b: sorted(set.intersection(set(a), set(b))), list1, list2)</span>
<span class="sd">            data.append(kw)</span>

<span class="sd">        import pandas as pd</span>
<span class="sd">        pd.options.display.max_rows = 1000</span>
<span class="sd">        pd.options.display.width = 1000</span>
<span class="sd">        df = pd.DataFrame.from_dict(data)</span>
<span class="sd">        data_keys = list(grid.keys())</span>
<span class="sd">        other_keys = ut.setdiff(df.columns, data_keys)</span>
<span class="sd">        df = df.reindex(data_keys + other_keys, axis=1)</span>
<span class="sd">        df[&#39;abs_change&#39;] = df[&#39;ut&#39;] - df[&#39;py2&#39;]</span>
<span class="sd">        df[&#39;pct_change&#39;] = df[&#39;abs_change&#39;] / df[&#39;ut&#39;] * 100</span>
<span class="sd">        #print(df.sort(&#39;abs_change&#39;, ascending=False))</span>

<span class="sd">        print(str(df).split(&#39;\n&#39;)[0])</span>
<span class="sd">        for row in df.values:</span>
<span class="sd">            argmin = row[len(data_keys):len(data_keys) + len(other_keys)].argmin() + len(data_keys)</span>
<span class="sd">            print(&#39;    &#39; + &#39;, &#39;.join([</span>
<span class="sd">            &#39;%6d&#39; % (r) if x &lt; len(data_keys) else (</span>
<span class="sd">                ut.color_text(&#39;%8.6f&#39; % (r,), &#39;blue&#39;)</span>
<span class="sd">                    if x == argmin else &#39;%8.6f&#39; % (r,))</span>
<span class="sd">            for x, r in enumerate(row)</span>
<span class="sd">            ]))</span>

<span class="sd">        %timeit ut.isect(list1, list2)</span>
<span class="sd">        %timeit np.intersect1d(list1, list2, assume_unique=True)</span>
<span class="sd">        %timeit set.intersection(set(list1), set(list2))</span>

<span class="sd">        #def highlight_max(s):</span>
<span class="sd">        #    &#39;&#39;&#39;</span>
<span class="sd">        #    highlight the maximum in a Series yellow.</span>
<span class="sd">        #    &#39;&#39;&#39;</span>
<span class="sd">        #    is_max = s == s.max()</span>
<span class="sd">        #    return [&#39;background-color: yellow&#39; if v else &#39;&#39; for v in is_max]</span>
<span class="sd">        #df.style.apply(highlight_max)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">list2</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list1</span> <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">set2</span><span class="p">]</span></div>


<div class="viewcode-block" id="union_ordered"><a class="viewcode-back" href="../../utool.html#utool.util_list.union_ordered">[docs]</a><span class="k">def</span> <span class="nf">union_ordered</span><span class="p">(</span><span class="o">*</span><span class="n">lists</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">unique_ordered</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">lists</span><span class="p">))</span></div>


<div class="viewcode-block" id="union"><a class="viewcode-back" href="../../utool.html#utool.util_list.union">[docs]</a><span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="o">*</span><span class="n">lists</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ignore:</span>
<span class="sd">        %timeit len(reduce(set.union, map(set, x)))</span>
<span class="sd">        %timeit len(ut.union(*x))</span>
<span class="sd">        %timeit len(ut.unique(ut.flatten(ut.lmap(np.unique, x))))</span>
<span class="sd">        %timeit len(ut.unique(ut.flatten(x)))</span>
<span class="sd">        %timeit len(ut.union(*x))</span>
<span class="sd">        %timeit len(ut.list_union(*x))</span>
<span class="sd">        %timeit len(set.union(*[set(list_) for list_ in lists]))</span>
<span class="sd">        %timeit len(set.union(*(set(list_) for list_ in lists)))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ordered&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">union_ordered</span><span class="p">(</span><span class="o">*</span><span class="n">lists</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">list_union</span><span class="p">(</span><span class="o">*</span><span class="n">lists</span><span class="p">)</span></div>


<div class="viewcode-block" id="list_intersection"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_intersection">[docs]</a><span class="k">def</span> <span class="nf">list_intersection</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">list2</span><span class="p">))</span></div>


<div class="viewcode-block" id="list_issubset"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_issubset">[docs]</a><span class="k">def</span> <span class="nf">list_issubset</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">list2</span><span class="p">))</span></div>


<div class="viewcode-block" id="list_issuperset"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_issuperset">[docs]</a><span class="k">def</span> <span class="nf">list_issuperset</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">list2</span><span class="p">))</span></div>


<div class="viewcode-block" id="list_isdisjoint"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_isdisjoint">[docs]</a><span class="k">def</span> <span class="nf">list_isdisjoint</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">list2</span><span class="p">))</span></div>


<div class="viewcode-block" id="list_union"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_union">[docs]</a><span class="k">def</span> <span class="nf">list_union</span><span class="p">(</span><span class="o">*</span><span class="n">lists</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span> <span class="k">for</span> <span class="n">list_</span> <span class="ow">in</span> <span class="n">lists</span><span class="p">))</span></div>
    <span class="c1"># return set.union(*[set(list_) for list_ in lists])</span>


<div class="viewcode-block" id="isect_indices"><a class="viewcode-back" href="../../utool.html#utool.util_list.isect_indices">[docs]</a><span class="k">def</span> <span class="nf">isect_indices</span><span class="p">(</span><span class="n">items1</span><span class="p">,</span> <span class="n">items2</span><span class="p">):</span>
    <span class="n">set1_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">items1</span><span class="p">)</span>
    <span class="n">set2_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">items2</span><span class="p">)</span>
    <span class="n">items_isect</span> <span class="o">=</span> <span class="n">set1_</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">set2_</span><span class="p">)</span>
    <span class="n">idxs1</span> <span class="o">=</span> <span class="n">find_list_indexes</span><span class="p">(</span><span class="n">items1</span><span class="p">,</span> <span class="n">items_isect</span><span class="p">)</span>
    <span class="n">idxs2</span> <span class="o">=</span> <span class="n">find_list_indexes</span><span class="p">(</span><span class="n">items2</span><span class="p">,</span> <span class="n">items_isect</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">idxs1</span><span class="p">,</span> <span class="n">idxs2</span></div>


<span class="n">intersect_ordered</span> <span class="o">=</span> <span class="n">isect</span>

<span class="n">is_subset</span> <span class="o">=</span> <span class="n">list_issubset</span>
<span class="n">is_superset</span> <span class="o">=</span> <span class="n">list_issuperset</span>

<span class="n">issubset</span> <span class="o">=</span> <span class="n">list_issubset</span>
<span class="n">issuperset</span> <span class="o">=</span> <span class="n">list_issuperset</span>
<span class="n">isdisjoint</span> <span class="o">=</span> <span class="n">list_isdisjoint</span>


<div class="viewcode-block" id="list_set_equal"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_set_equal">[docs]</a><span class="k">def</span> <span class="nf">list_set_equal</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">list2</span><span class="p">)</span></div>


<div class="viewcode-block" id="is_subset_of_any"><a class="viewcode-back" href="../../utool.html#utool.util_list.is_subset_of_any">[docs]</a><span class="k">def</span> <span class="nf">is_subset_of_any</span><span class="p">(</span><span class="n">set_</span><span class="p">,</span> <span class="n">other_sets</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns True if set_ is a subset of any set in other_sets</span>

<span class="sd">    Args:</span>
<span class="sd">        set_ (set):</span>
<span class="sd">        other_sets (list of sets):</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: flag</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-is_subset_of_any</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; # build test data</span>
<span class="sd">        &gt;&gt;&gt; set_ = {1, 2}</span>
<span class="sd">        &gt;&gt;&gt; other_sets = [{1, 4}, {3, 2, 1}]</span>
<span class="sd">        &gt;&gt;&gt; # execute function</span>
<span class="sd">        &gt;&gt;&gt; result = is_subset_of_any(set_, other_sets)</span>
<span class="sd">        &gt;&gt;&gt; # verify results</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        True</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; # build test data</span>
<span class="sd">        &gt;&gt;&gt; set_ = {1, 2}</span>
<span class="sd">        &gt;&gt;&gt; other_sets = [{1, 4}, {3, 2}]</span>
<span class="sd">        &gt;&gt;&gt; # execute function</span>
<span class="sd">        &gt;&gt;&gt; result = is_subset_of_any(set_, other_sets)</span>
<span class="sd">        &gt;&gt;&gt; # verify results</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">set_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">set_</span><span class="p">)</span>
    <span class="n">other_sets</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="n">other_sets</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">any</span><span class="p">([</span><span class="n">set_</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">other_set</span><span class="p">)</span> <span class="k">for</span> <span class="n">other_set</span> <span class="ow">in</span> <span class="n">other_sets</span><span class="p">])</span></div>


<div class="viewcode-block" id="priority_sort"><a class="viewcode-back" href="../../utool.html#utool.util_list.priority_sort">[docs]</a><span class="k">def</span> <span class="nf">priority_sort</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">priority</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        list_ (list):</span>
<span class="sd">        priority (list): desired order of items</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: reordered_list</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-priority_argsort</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list_ = [2, 4, 6, 8, 10]</span>
<span class="sd">        &gt;&gt;&gt; priority = [8, 2, 6, 9]</span>
<span class="sd">        &gt;&gt;&gt; reordered_list = priority_sort(list_, priority)</span>
<span class="sd">        &gt;&gt;&gt; result = str(reordered_list)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [8, 2, 6, 4, 10]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># remove requested priority items not in the list</span>
    <span class="n">priority_</span> <span class="o">=</span> <span class="n">setintersect_ordered</span><span class="p">(</span><span class="n">priority</span><span class="p">,</span> <span class="n">list_</span><span class="p">)</span>
    <span class="n">reordered_list</span> <span class="o">=</span> <span class="n">unique_ordered</span><span class="p">(</span><span class="n">priority_</span> <span class="o">+</span> <span class="n">list_</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">reordered_list</span></div>


<div class="viewcode-block" id="priority_argsort"><a class="viewcode-back" href="../../utool.html#utool.util_list.priority_argsort">[docs]</a><span class="k">def</span> <span class="nf">priority_argsort</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">priority</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        list_ (list):</span>
<span class="sd">        priority (list): desired order of items</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: reordered_index_list</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; list_ = [2, 4, 6, 8, 10]</span>
<span class="sd">        &gt;&gt;&gt; priority = [8, 2, 6, 9]</span>
<span class="sd">        &gt;&gt;&gt; sortx = priority_argsort(list_, priority)</span>
<span class="sd">        &gt;&gt;&gt; reordered_list = priority_sort(list_, priority)</span>
<span class="sd">        &gt;&gt;&gt; assert ut.take(list_, sortx) == reordered_list</span>
<span class="sd">        &gt;&gt;&gt; result = str(sortx)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [3, 0, 2, 1, 4]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">reordered_list</span> <span class="o">=</span> <span class="n">priority_sort</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">priority</span><span class="p">)</span>
    <span class="c1"># FIXME: inefficient</span>
    <span class="n">sortx</span> <span class="o">=</span> <span class="p">[</span><span class="n">list_</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">reordered_list</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">sortx</span></div>


<div class="viewcode-block" id="flag_unique_items"><a class="viewcode-back" href="../../utool.html#utool.util_list.flag_unique_items">[docs]</a><span class="k">def</span> <span class="nf">flag_unique_items</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of flags corresponding to the first time an item is seen</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (list): list of items</span>

<span class="sd">    Returns:</span>
<span class="sd">        flag_list</span>

<span class="sd">    Timing:</span>
<span class="sd">        import random</span>
<span class="sd">        import utool as ut</span>

<span class="sd">        def random_items(n, m):</span>
<span class="sd">            rng = random.Random(0)</span>
<span class="sd">            return [rng.randint(0, n) for _ in range(m)]</span>

<span class="sd">        m = 1000</span>

<span class="sd">        def method1(list_):</span>
<span class="sd">            seen = set()</span>
<span class="sd">            def unseen(item):</span>
<span class="sd">                if item in seen:</span>
<span class="sd">                    return False</span>
<span class="sd">                seen.add(item)</span>
<span class="sd">                return True</span>
<span class="sd">            flag_list = [unseen(item) for item in list_]</span>
<span class="sd">            return flag_list</span>

<span class="sd">        def method2(list_):</span>
<span class="sd">            return ut.index_to_boolmask([list_.index(x) for x in set(list_)], len(list_))</span>

<span class="sd">        def method3(list_):</span>
<span class="sd">            return ut.index_to_boolmask(dict(zip(reversed(list_), reversed(range(len(list_))))).values(), len(list_))</span>


<span class="sd">        import ubelt as ub</span>
<span class="sd">        ub.Timerit.DEFAULT_VERBOSE = False</span>

<span class="sd">        ut.qtensure()</span>
<span class="sd">        exps = [0, .25, .5, .75, 1, 2]</span>
<span class="sd">        pnum_ = pt.make_pnum_nextgen(nSubplots=len(exps))</span>
<span class="sd">        current = ut.flag_unique_items</span>

<span class="sd">        for count, exp in ut.ProgIter(list(enumerate(exps, start=1))):</span>
<span class="sd">            ydatas = ut.ddict(list)</span>
<span class="sd">            xdata = []</span>
<span class="sd">            for m in ut.ProgIter(list(range(0, 10000, 100)), freq=1):</span>
<span class="sd">                xdata.append(m)</span>
<span class="sd">                num = 10</span>
<span class="sd">                n = int(m ** exp)</span>
<span class="sd">                list_ = random_items(n=n, m=m)</span>
<span class="sd">                ydatas[&#39;method1&#39;].append(ub.Timerit(num).call(method1, list_))</span>
<span class="sd">                ydatas[&#39;method2&#39;].append(ub.Timerit(num).call(method2, list_))</span>
<span class="sd">                ydatas[&#39;method3&#39;].append(ub.Timerit(num).call(method3, list_))</span>
<span class="sd">                ydatas[&#39;current&#39;].append(ub.Timerit(num).call(current, list_))</span>

<span class="sd">                # assert method1(list_) == method3(list_)</span>
<span class="sd">                # assert method1(list_) == current(list_)</span>

<span class="sd">            pt.multi_plot(</span>
<span class="sd">                xdata, list(ydatas.values()), label_list=list(ydatas.keys()),</span>
<span class="sd">                ylabel=&#39;time&#39;, title=str(exp), fnum=1, pnum=pnum_())</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">len_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span>
    <span class="n">item_to_index</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">list_</span><span class="p">),</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">len_</span><span class="p">))))</span>
    <span class="n">flag_list</span> <span class="o">=</span> <span class="n">index_to_boolmask</span><span class="p">(</span><span class="n">item_to_index</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">len_</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flag_list</span></div>


<span class="n">unique_flags</span> <span class="o">=</span> <span class="n">flag_unique_items</span>


<div class="viewcode-block" id="iflag_unique_items"><a class="viewcode-back" href="../../utool.html#utool.util_list.iflag_unique_items">[docs]</a><span class="k">def</span> <span class="nf">iflag_unique_items</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of flags corresponding to the first time an item is seen</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (list): list of items</span>

<span class="sd">    Returns:</span>
<span class="sd">        flag_iter</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">unseen</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="n">flag_iter</span> <span class="o">=</span> <span class="p">(</span><span class="n">unseen</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flag_iter</span></div>


<div class="viewcode-block" id="unique_ordered"><a class="viewcode-back" href="../../utool.html#utool.util_list.unique_ordered">[docs]</a><span class="k">def</span> <span class="nf">unique_ordered</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns unique items in ``list_`` in the order they were seen.</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: unique_list - unique list which maintains order</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --exec-unique_ordered</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list_ = [4, 6, 6, 0, 6, 1, 0, 2, 2, 1]</span>
<span class="sd">        &gt;&gt;&gt; unique_list = unique_ordered(list_)</span>
<span class="sd">        &gt;&gt;&gt; result = (&#39;unique_list = %s&#39; % (str(unique_list),))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        unique_list = [4, 6, 0, 1, 2]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">list_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span>
    <span class="n">flag_list</span> <span class="o">=</span> <span class="n">flag_unique_items</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span>
    <span class="n">unique_list</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">flag_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unique_list</span></div>


<div class="viewcode-block" id="unique_unordered"><a class="viewcode-back" href="../../utool.html#utool.util_list.unique_unordered">[docs]</a><span class="k">def</span> <span class="nf">unique_unordered</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    wrapper around list(set(list_))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">list_</span><span class="p">))</span></div>


<div class="viewcode-block" id="unique_indices"><a class="viewcode-back" href="../../utool.html#utool.util_list.unique_indices">[docs]</a><span class="k">def</span> <span class="nf">unique_indices</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">flag_unique_items</span><span class="p">(</span><span class="n">list_</span><span class="p">))</span></div>


<div class="viewcode-block" id="unique"><a class="viewcode-back" href="../../utool.html#utool.util_list.unique">[docs]</a><span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">ordered</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns unique items in ``list_``.</span>
<span class="sd">    Generally, unordered (*should be) faster.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">ordered</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">unique_ordered</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">unique_unordered</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span></div>


<div class="viewcode-block" id="flat_unique"><a class="viewcode-back" href="../../utool.html#utool.util_list.flat_unique">[docs]</a><span class="k">def</span> <span class="nf">flat_unique</span><span class="p">(</span><span class="o">*</span><span class="n">lists_</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; returns items unique across all lists &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">unique</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">lists_</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="setdiff"><a class="viewcode-back" href="../../utool.html#utool.util_list.setdiff">[docs]</a><span class="k">def</span> <span class="nf">setdiff</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns list1 elements that are not in list2. preserves order of list1</span>

<span class="sd">    Args:</span>
<span class="sd">        list1 (list):</span>
<span class="sd">        list2 (list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: new_list</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; list1 = [&#39;featweight_rowid&#39;, &#39;feature_rowid&#39;, &#39;config_rowid&#39;, &#39;featweight_forground_weight&#39;]</span>
<span class="sd">        &gt;&gt;&gt; list2 = [u&#39;featweight_rowid&#39;]</span>
<span class="sd">        &gt;&gt;&gt; new_list = setdiff_ordered(list1, list2)</span>
<span class="sd">        &gt;&gt;&gt; result = ut.repr4(new_list, nl=False)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [&#39;feature_rowid&#39;, &#39;config_rowid&#39;, &#39;featweight_forground_weight&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">list2</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list1</span> <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">set2</span><span class="p">]</span></div>


<div class="viewcode-block" id="setdiff_flags"><a class="viewcode-back" href="../../utool.html#utool.util_list.setdiff_flags">[docs]</a><span class="k">def</span> <span class="nf">setdiff_flags</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">isetdiff_flags</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">))</span></div>


<div class="viewcode-block" id="isetdiff_flags"><a class="viewcode-back" href="../../utool.html#utool.util_list.isetdiff_flags">[docs]</a><span class="k">def</span> <span class="nf">isetdiff_flags</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    move to util_iter</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">list2</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">set2</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list1</span><span class="p">)</span></div>


<span class="n">setdiff_ordered</span> <span class="o">=</span> <span class="n">setdiff</span>


<div class="viewcode-block" id="setintersect_ordered"><a class="viewcode-back" href="../../utool.html#utool.util_list.setintersect_ordered">[docs]</a><span class="k">def</span> <span class="nf">setintersect_ordered</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns list1 elements that are in list2. preserves order of list1</span>

<span class="sd">    setintersect_ordered</span>

<span class="sd">    Args:</span>
<span class="sd">        list1 (list):</span>
<span class="sd">        list2 (list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: new_list</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list1 = [1, 2, 3, 5, 8, 13, 21]</span>
<span class="sd">        &gt;&gt;&gt; list2 = [6, 4, 2, 21, 8]</span>
<span class="sd">        &gt;&gt;&gt; new_list = setintersect_ordered(list1, list2)</span>
<span class="sd">        &gt;&gt;&gt; result = new_list</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [2, 8, 21]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list1</span> <span class="k">if</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">list2</span><span class="p">)]</span></div>


<span class="n">setintersect</span> <span class="o">=</span> <span class="n">setintersect_ordered</span>


<div class="viewcode-block" id="sortedby"><a class="viewcode-back" href="../../utool.html#utool.util_list.sortedby">[docs]</a><span class="k">def</span> <span class="nf">sortedby</span><span class="p">(</span><span class="n">item_list</span><span class="p">,</span> <span class="n">key_list</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; sorts ``item_list`` using key_list</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (list): list to sort</span>
<span class="sd">        key_list (list): list to sort by</span>
<span class="sd">        reverse (bool): sort order is descending (largest first)</span>
<span class="sd">                        if reverse is True else acscending (smallest first)</span>

<span class="sd">    Returns:</span>
<span class="sd">        list : ``list_`` sorted by the values of another ``list``. defaults to</span>
<span class="sd">        ascending order</span>

<span class="sd">    SeeAlso:</span>
<span class="sd">        sortedby2</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; import utool</span>
<span class="sd">        &gt;&gt;&gt; list_    = [1, 2, 3, 4, 5]</span>
<span class="sd">        &gt;&gt;&gt; key_list = [2, 5, 3, 1, 5]</span>
<span class="sd">        &gt;&gt;&gt; result = utool.sortedby(list_, key_list, reverse=True)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [5, 2, 3, 1, 4]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">item_list</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">key_list</span><span class="p">),</span> <span class="s1">&#39;Expected same len. Got: </span><span class="si">%r</span><span class="s1"> != </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">item_list</span><span class="p">),</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">key_list</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">sorted_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">item</span> <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">key_list</span><span class="p">,</span> <span class="n">item_list</span><span class="p">)),</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">sorted_list</span></div>


<div class="viewcode-block" id="sortedby2"><a class="viewcode-back" href="../../utool.html#utool.util_list.sortedby2">[docs]</a><span class="k">def</span> <span class="nf">sortedby2</span><span class="p">(</span><span class="n">item_list</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; sorts ``item_list`` using key_list</span>

<span class="sd">    Args:</span>
<span class="sd">        item_list (list): list to sort</span>
<span class="sd">        *args: multiple lists to sort by</span>
<span class="sd">        **kwargs:</span>
<span class="sd">            reverse (bool): sort order is descending if True else acscending</span>

<span class="sd">    Returns:</span>
<span class="sd">        list : ``list_`` sorted by the values of another ``list``. defaults to</span>
<span class="sd">        ascending order</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --exec-sortedby2 --show</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; item_list = [1, 2, 3, 4, 5]</span>
<span class="sd">        &gt;&gt;&gt; key_list1 = [1, 1, 2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; key_list2 = [2, 1, 4, 1, 1]</span>
<span class="sd">        &gt;&gt;&gt; args = (key_list1, key_list2)</span>
<span class="sd">        &gt;&gt;&gt; kwargs = dict(reverse=False)</span>
<span class="sd">        &gt;&gt;&gt; result = ut.sortedby2(item_list, *args, **kwargs)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [2, 1, 3, 4, 5]</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; # Python 3 Compatibility Test</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; item_list = [1, 2, 3, 4, 5]</span>
<span class="sd">        &gt;&gt;&gt; key_list1 = [&#39;a&#39;, &#39;a&#39;, 2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; key_list2 = [&#39;b&#39;, &#39;a&#39;, 4, 1, 1]</span>
<span class="sd">        &gt;&gt;&gt; args = (key_list1, key_list2)</span>
<span class="sd">        &gt;&gt;&gt; kwargs = dict(reverse=False)</span>
<span class="sd">        &gt;&gt;&gt; result = ut.sortedby2(item_list, *args, **kwargs)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [3, 4, 5, 2, 1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="nb">all</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">item_list</span><span class="p">)</span> <span class="o">==</span> <span class="n">len_</span> <span class="k">for</span> <span class="n">len_</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">args</span><span class="p">)])</span>
    <span class="n">reverse</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reverse&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">tup_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">item_list</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
    <span class="c1"># print(tup_list)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sorted_tups</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tup_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="c1"># Python 3 does not allow sorting mixed types</span>
        <span class="k">def</span> <span class="nf">keyfunc</span><span class="p">(</span><span class="n">tup</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

        <span class="n">sorted_tups</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tup_list</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">keyfunc</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
    <span class="n">sorted_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">sorted_tups</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">sorted_list</span></div>


<div class="viewcode-block" id="unflat_take"><a class="viewcode-back" href="../../utool.html#utool.util_list.unflat_take">[docs]</a><span class="k">def</span> <span class="nf">unflat_take</span><span class="p">(</span><span class="n">items_list</span><span class="p">,</span> <span class="n">unflat_index_list</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns nested subset of items_list</span>

<span class="sd">    Args:</span>
<span class="sd">        items_list (list):</span>
<span class="sd">        unflat_index_list (list): nested list of indices</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --exec-unflat_take</span>

<span class="sd">    SeeAlso:</span>
<span class="sd">        ut.take</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; items_list = [1, 2, 3, 4, 5]</span>
<span class="sd">        &gt;&gt;&gt; unflat_index_list = [[0, 1], [2, 3], [0, 4]]</span>
<span class="sd">        &gt;&gt;&gt; result = unflat_take(items_list, unflat_index_list)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[1, 2], [3, 4], [1, 5]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span>
        <span class="n">unflat_take</span><span class="p">(</span><span class="n">items_list</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="n">take</span><span class="p">(</span><span class="n">items_list</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">xs</span> <span class="ow">in</span> <span class="n">unflat_index_list</span>
    <span class="p">]</span></div>


<div class="viewcode-block" id="argsort"><a class="viewcode-back" href="../../utool.html#utool.util_list.argsort">[docs]</a><span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    like np.argsort but for lists</span>

<span class="sd">    Args:</span>
<span class="sd">        *args: multiple lists to sort by</span>
<span class="sd">        **kwargs:</span>
<span class="sd">            reverse (bool): sort order is descending if True else acscending</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list argsort</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; result = ut.argsort({&#39;a&#39;: 3, &#39;b&#39;: 2, &#39;c&#39;: 100})</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">dict_</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">index_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dict_</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">value_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dict_</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">sortedby2</span><span class="p">(</span><span class="n">index_list</span><span class="p">,</span> <span class="n">value_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">index_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
        <span class="k">return</span> <span class="n">sortedby2</span><span class="p">(</span><span class="n">index_list</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="argsort2"><a class="viewcode-back" href="../../utool.html#utool.util_list.argsort2">[docs]</a><span class="k">def</span> <span class="nf">argsort2</span><span class="p">(</span><span class="n">indexable</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the indices that would sort a indexable object.</span>

<span class="sd">    This is similar to np.argsort, but it is written in pure python and works</span>
<span class="sd">    on both lists and dictionaries.</span>

<span class="sd">    Args:</span>
<span class="sd">        indexable (list or dict): indexable to sort by</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: indices: list of indices such that sorts the indexable</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; # argsort works on dicts</span>
<span class="sd">        &gt;&gt;&gt; dict_ = indexable = {&#39;a&#39;: 3, &#39;b&#39;: 2, &#39;c&#39;: 100}</span>
<span class="sd">        &gt;&gt;&gt; indices = ut.argsort2(indexable)</span>
<span class="sd">        &gt;&gt;&gt; assert list(ut.take(dict_, indices)) == sorted(dict_.values())</span>
<span class="sd">        &gt;&gt;&gt; # argsort works on lists</span>
<span class="sd">        &gt;&gt;&gt; indexable = [100, 2, 432, 10]</span>
<span class="sd">        &gt;&gt;&gt; indices = ut.argsort2(indexable)</span>
<span class="sd">        &gt;&gt;&gt; assert list(ut.take(indexable, indices)) == sorted(indexable)</span>
<span class="sd">        &gt;&gt;&gt; # argsort works on iterators</span>
<span class="sd">        &gt;&gt;&gt; indexable = reversed(range(100))</span>
<span class="sd">        &gt;&gt;&gt; indices = ut.argsort2(indexable)</span>
<span class="sd">        &gt;&gt;&gt; assert indices[0] == 99</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create an iterator of value/key pairs</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indexable</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">vk_iter</span> <span class="o">=</span> <span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">indexable</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">vk_iter</span> <span class="o">=</span> <span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indexable</span><span class="p">))</span>
    <span class="c1"># Sort by values and extract the keys</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">vk_iter</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">k</span> <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">vk_iter</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">vk</span><span class="p">:</span> <span class="n">key</span><span class="p">(</span><span class="n">vk</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="k">return</span> <span class="n">indices</span></div>


<div class="viewcode-block" id="argmax"><a class="viewcode-back" href="../../utool.html#utool.util_list.argmax">[docs]</a><span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="n">input_</span><span class="p">,</span> <span class="n">multi</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns index / key of the item with the largest value.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_ (dict or list):</span>

<span class="sd">    References:</span>
<span class="sd">        http://stackoverflow.com/questions/16945518/python-argmin-argmax</span>

<span class="sd">    Ignore:</span>
<span class="sd">        list_ = np.random.rand(10000).tolist()</span>
<span class="sd">        %timeit list_.index(max(list_))</span>
<span class="sd">        %timeit max(enumerate(list_), key=operator.itemgetter(1))[0]</span>
<span class="sd">        %timeit max(enumerate(list_), key=lambda x: x[1])[0]</span>
<span class="sd">        %timeit max(range(len(list_)), key=list_.__getitem__)</span>

<span class="sd">        input_ = dict_</span>
<span class="sd">        list_ = np.random.rand(100000).tolist()</span>
<span class="sd">        dict_ = {str(ut.random_uuid()): x for x in list_}</span>
<span class="sd">        %timeit list(input_.keys())[ut.argmax(list(input_.values()))]</span>
<span class="sd">        %timeit max(input_.items(), key=operator.itemgetter(1))[0]</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; input_ = [1, 2, 3, 3, 2, 3, 2, 1]</span>
<span class="sd">        &gt;&gt;&gt; ut.argmax(input_, multi=True)</span>
<span class="sd">        &gt;&gt;&gt; input_ = {1: 4, 2: 2, 3: 3, 3: 4}</span>
<span class="sd">        &gt;&gt;&gt; ut.argmax(input_, multi=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">multi</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">keys</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">argmax</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">multi</span><span class="o">=</span><span class="n">multi</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">equal</span><span class="p">([</span><span class="nb">max</span><span class="p">(</span><span class="n">input_</span><span class="p">)],</span> <span class="n">input_</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">input_</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="c1"># its crazy, but this is faster</span>
            <span class="c1"># max(input_.items(), key=operator.itemgetter(1))[0]</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="n">argmax</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">input_</span><span class="o">.</span><span class="n">values</span><span class="p">()))]</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">input_</span><span class="p">,</span> <span class="s1">&#39;index&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">input_</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">input_</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">input_</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="argmin"><a class="viewcode-back" href="../../utool.html#utool.util_list.argmin">[docs]</a><span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="n">input_</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns index / key of the item with the smallest value.</span>

<span class="sd">    Args:</span>
<span class="sd">        input_ (dict or list):</span>

<span class="sd">    Note:</span>
<span class="sd">        a[argmin(a, key=key)] == min(a, key=key)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># if isinstance(input_, dict):</span>
    <span class="c1">#     return list(input_.keys())[argmin(list(input_.values()))]</span>
    <span class="c1"># elif hasattr(input_, &#39;index&#39;):</span>
    <span class="c1">#     return input_.index(min(input_))</span>
    <span class="c1"># else:</span>
    <span class="c1">#     return min(enumerate(input_), key=operator.itemgetter(1))[0]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="n">argmin</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">_key</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">_key</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">key</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="nb">input</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="n">_key</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="index_complement"><a class="viewcode-back" href="../../utool.html#utool.util_list.index_complement">[docs]</a><span class="k">def</span> <span class="nf">index_complement</span><span class="p">(</span><span class="n">index_list</span><span class="p">,</span> <span class="n">len_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the other indicies in a list of length ``len_``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask1</span> <span class="o">=</span> <span class="n">index_to_boolmask</span><span class="p">(</span><span class="n">index_list</span><span class="p">,</span> <span class="n">len_</span><span class="p">)</span>
    <span class="n">mask2</span> <span class="o">=</span> <span class="n">not_list</span><span class="p">(</span><span class="n">mask1</span><span class="p">)</span>
    <span class="n">index_list_bar</span> <span class="o">=</span> <span class="n">list_where</span><span class="p">(</span><span class="n">mask2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">index_list_bar</span></div>


<div class="viewcode-block" id="take_complement"><a class="viewcode-back" href="../../utool.html#utool.util_list.take_complement">[docs]</a><span class="k">def</span> <span class="nf">take_complement</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">index_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Returns items in ``list_`` not indexed by index_list &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">not_list</span><span class="p">(</span><span class="n">index_to_boolmask</span><span class="p">(</span><span class="n">index_list</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">compress</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span></div>


<div class="viewcode-block" id="none_take"><a class="viewcode-back" href="../../utool.html#utool.util_list.none_take">[docs]</a><span class="k">def</span> <span class="nf">none_take</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">index_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Like take but indices can be None</span>

<span class="sd">    SeeAlso:</span>
<span class="sd">        ut.take</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="kc">None</span> <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">list_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">]</span></div>


<div class="viewcode-block" id="take"><a class="viewcode-back" href="../../utool.html#utool.util_list.take">[docs]</a><span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">index_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selects a subset of a list based on a list of indices.</span>
<span class="sd">    This is similar to np.take, but pure python.</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (list): some indexable object</span>
<span class="sd">        index_list (list, slice, int): some indexing object</span>

<span class="sd">    Returns:</span>
<span class="sd">        list or scalar: subset of the list</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-take</span>

<span class="sd">    SeeAlso:</span>
<span class="sd">        ut.dict_take</span>
<span class="sd">        ut.dict_subset</span>
<span class="sd">        ut.none_take</span>
<span class="sd">        ut.compress</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list_ = [0, 1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; index_list = [2, 0]</span>
<span class="sd">        &gt;&gt;&gt; result = take(list_, index_list)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [2, 0]</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list_ = [0, 1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; index = 2</span>
<span class="sd">        &gt;&gt;&gt; result = take(list_, index)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        2</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list_ = [0, 1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; index = slice(1, None, 2)</span>
<span class="sd">        &gt;&gt;&gt; result = take(list_, index)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [1, 3]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">list_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">list_</span><span class="p">[</span><span class="n">index_list</span><span class="p">]</span></div>
    <span class="c1"># if util_iter.isiterable(index_list):</span>
    <span class="c1"># else:</span>


<span class="c1"># def take</span>

<span class="c1"># def take2(item_list, indicies, axis):</span>
<span class="c1">#     def _get_axes(list_, axis);</span>
<span class="c1">#     pass</span>


<div class="viewcode-block" id="take_percentile"><a class="viewcode-back" href="../../utool.html#utool.util_list.take_percentile">[docs]</a><span class="k">def</span> <span class="nf">take_percentile</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">percent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; take the top `percent` items in a list rounding up &quot;&quot;&quot;</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="n">percent</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">stop</span><span class="p">]</span></div>


<div class="viewcode-block" id="snapped_slice"><a class="viewcode-back" href="../../utool.html#utool.util_list.snapped_slice">[docs]</a><span class="k">def</span> <span class="nf">snapped_slice</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">frac</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a slice spanning `n` items in a list of length `size` at position</span>
<span class="sd">    `frac`.</span>

<span class="sd">    Args:</span>
<span class="sd">        size (int): length of the list</span>
<span class="sd">        frac (float): position in the range [0, 1]</span>
<span class="sd">        n (int): number of items in the slice</span>

<span class="sd">    Returns:</span>
<span class="sd">        slice: slice object that best fits the criteria</span>

<span class="sd">    SeeAlso:</span>
<span class="sd">        take_percentile_parts</span>

<span class="sd">    Example:</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; print(snapped_slice(0, 0, 10))</span>
<span class="sd">        &gt;&gt;&gt; print(snapped_slice(1, 0, 10))</span>
<span class="sd">        &gt;&gt;&gt; print(snapped_slice(100, 0, 10))</span>
<span class="sd">        &gt;&gt;&gt; print(snapped_slice(9, 0, 10))</span>
<span class="sd">        &gt;&gt;&gt; print(snapped_slice(100, 1, 10))</span>
<span class="sd">        pass</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">size</span>
    <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="n">frac</span> <span class="o">-</span> <span class="n">ceil</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="n">frac</span> <span class="o">+</span> <span class="n">floor</span><span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1"># slide to the front or the back</span>
    <span class="n">buf</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">:</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">stop</span>
    <span class="k">elif</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">-</span> <span class="n">start</span>
    <span class="n">stop</span> <span class="o">+=</span> <span class="n">buf</span>
    <span class="n">start</span> <span class="o">+=</span> <span class="n">buf</span>
    <span class="k">assert</span> <span class="n">stop</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="p">,</span> <span class="s1">&#39;out of bounds [</span><span class="si">%r</span><span class="s1">, </span><span class="si">%r</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
    <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sl</span></div>


<div class="viewcode-block" id="take_around_percentile"><a class="viewcode-back" href="../../utool.html#utool.util_list.take_around_percentile">[docs]</a><span class="k">def</span> <span class="nf">take_around_percentile</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">frac</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">arr</span><span class="p">[</span><span class="n">snapped_slice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">frac</span><span class="p">,</span> <span class="n">n</span><span class="p">)]</span></div>


<div class="viewcode-block" id="flag_percentile_parts"><a class="viewcode-back" href="../../utool.html#utool.util_list.flag_percentile_parts">[docs]</a><span class="k">def</span> <span class="nf">flag_percentile_parts</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">front</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">back</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">front</span><span class="p">:</span>
        <span class="n">slices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">snapped_slice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">front</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">mid</span><span class="p">:</span>
        <span class="n">slices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">snapped_slice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">mid</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">back</span><span class="p">:</span>
        <span class="n">slices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">snapped_slice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">back</span><span class="p">)]</span>

    <span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>

    <span class="n">indices</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
        <span class="nb">set</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">sl</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)))</span> <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">index_to_boolmask</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">flags</span></div>


<div class="viewcode-block" id="take_percentile_parts"><a class="viewcode-back" href="../../utool.html#utool.util_list.take_percentile_parts">[docs]</a><span class="k">def</span> <span class="nf">take_percentile_parts</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">front</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">back</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Take parts from front, back, or middle of a list</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; arr = list(range(20))</span>
<span class="sd">        &gt;&gt;&gt; front = 3</span>
<span class="sd">        &gt;&gt;&gt; mid = 3</span>
<span class="sd">        &gt;&gt;&gt; back = 3</span>
<span class="sd">        &gt;&gt;&gt; result = take_percentile_parts(arr, front, mid, back)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [0, 1, 2, 9, 10, 11, 17, 18, 19]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">front</span><span class="p">:</span>
        <span class="n">slices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">snapped_slice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">front</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">mid</span><span class="p">:</span>
        <span class="n">slices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">snapped_slice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">mid</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">back</span><span class="p">:</span>
        <span class="n">slices</span> <span class="o">+=</span> <span class="p">[</span><span class="n">snapped_slice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">back</span><span class="p">)]</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">([</span><span class="n">arr</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span> <span class="k">for</span> <span class="n">sl</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">parts</span></div>


<div class="viewcode-block" id="list_inverse_take"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_inverse_take">[docs]</a><span class="k">def</span> <span class="nf">list_inverse_take</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">index_list</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        list_ (list): list in sorted domain</span>
<span class="sd">        index_list (list): index list of the unsorted domain</span>

<span class="sd">    Note:</span>
<span class="sd">        Seems to be logically equivalent to</span>
<span class="sd">        ut.take(list_, ut.argsort(index_list)), but faster</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: output_list_ - the input list in the unsorted domain</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-list_inverse_take</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; # build test data</span>
<span class="sd">        &gt;&gt;&gt; rank_list = [3, 2, 4, 1, 9, 2]</span>
<span class="sd">        &gt;&gt;&gt; prop_list = [0, 1, 2, 3, 4, 5]</span>
<span class="sd">        &gt;&gt;&gt; index_list = ut.argsort(rank_list)</span>
<span class="sd">        &gt;&gt;&gt; sorted_prop_list = ut.take(prop_list, index_list)</span>
<span class="sd">        &gt;&gt;&gt; # execute function</span>
<span class="sd">        &gt;&gt;&gt; list_ = sorted_prop_list</span>
<span class="sd">        &gt;&gt;&gt; output_list_  = list_inverse_take(list_, index_list)</span>
<span class="sd">        &gt;&gt;&gt; output_list2_ = ut.take(list_, ut.argsort(index_list))</span>
<span class="sd">        &gt;&gt;&gt; assert output_list_ == prop_list</span>
<span class="sd">        &gt;&gt;&gt; assert output_list2_ == prop_list</span>
<span class="sd">        &gt;&gt;&gt; # verify results</span>
<span class="sd">        &gt;&gt;&gt; result = str(output_list_)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>

<span class="sd">    Timeit::</span>
<span class="sd">        %timeit list_inverse_take(list_, index_list)</span>
<span class="sd">        %timeit ut.take(list_, ut.argsort(index_list))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output_list_</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">item</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">index_list</span><span class="p">):</span>
        <span class="n">output_list_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span>
    <span class="k">return</span> <span class="n">output_list_</span></div>


<div class="viewcode-block" id="broadcast_zip"><a class="viewcode-back" href="../../utool.html#utool.util_list.broadcast_zip">[docs]</a><span class="k">def</span> <span class="nf">broadcast_zip</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Zips elementwise pairs between list1 and list2. Broadcasts</span>
<span class="sd">    the first dimension if a single list is of length 1.</span>

<span class="sd">    Aliased as bzip</span>

<span class="sd">    Args:</span>
<span class="sd">        list1 (list):</span>
<span class="sd">        list2 (list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: list of pairs</span>

<span class="sd">    SeeAlso:</span>
<span class="sd">        util_dict.dzip</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if the list dimensions are not broadcastable</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; assert list(bzip([1, 2, 3], [4])) == [(1, 4), (2, 4), (3, 4)]</span>
<span class="sd">        &gt;&gt;&gt; assert list(bzip([1, 2, 3], [4, 4, 4])) == [(1, 4), (2, 4), (3, 4)]</span>
<span class="sd">        &gt;&gt;&gt; assert list(bzip([1], [4, 4, 4])) == [(1, 4), (1, 4), (1, 4)]</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_raises(ValueError, bzip, [1, 2, 3], [])</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_raises(ValueError, bzip, [], [4, 5, 6])</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_raises(ValueError, bzip, [], [4])</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_raises(ValueError, bzip, [1, 2], [4, 5, 6])</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_raises(ValueError, bzip, [1, 2, 3], [4, 5])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">list1</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">list2</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">list2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">list2</span><span class="p">)</span>
    <span class="c1"># if len(list1) == 0 or len(list2) == 0:</span>
    <span class="c1">#     # Corner case where either list is empty</span>
    <span class="c1">#     return []</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">list2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">list1</span> <span class="o">=</span> <span class="n">list1</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">list2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">list2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">list2</span> <span class="o">=</span> <span class="n">list2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s1">&#39;out of alignment len(list1)=</span><span class="si">%r</span><span class="s1">, len(list2)=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">list2</span><span class="p">))</span>
        <span class="p">)</span>
    <span class="c1"># return list(zip(list1, list2))</span>
    <span class="k">return</span> <span class="nb">zip</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">)</span></div>


<div class="viewcode-block" id="where"><a class="viewcode-back" href="../../utool.html#utool.util_list.where">[docs]</a><span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">flag_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; takes flags returns indexes of True values &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">flag</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">flag_list</span><span class="p">)</span> <span class="k">if</span> <span class="n">flag</span><span class="p">]</span></div>


<div class="viewcode-block" id="equal"><a class="viewcode-back" href="../../utool.html#utool.util_list.equal">[docs]</a><span class="k">def</span> <span class="nf">equal</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; takes flags returns indexes of True values &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item1</span> <span class="o">==</span> <span class="n">item2</span> <span class="k">for</span> <span class="n">item1</span><span class="p">,</span> <span class="n">item2</span> <span class="ow">in</span> <span class="n">broadcast_zip</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">)]</span></div>


<div class="viewcode-block" id="where_not_None"><a class="viewcode-back" href="../../utool.html#utool.util_list.where_not_None">[docs]</a><span class="k">def</span> <span class="nf">where_not_None</span><span class="p">(</span><span class="n">item_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; returns list of indexes of non None values</span>

<span class="sd">    SeeAlso:</span>
<span class="sd">        flag_None_items</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">index</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">item_list</span><span class="p">)</span> <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span></div>


<div class="viewcode-block" id="flag_None_items"><a class="viewcode-back" href="../../utool.html#utool.util_list.flag_None_items">[docs]</a><span class="k">def</span> <span class="nf">flag_None_items</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_</span><span class="p">]</span></div>


<div class="viewcode-block" id="flag_not_None_items"><a class="viewcode-back" href="../../utool.html#utool.util_list.flag_not_None_items">[docs]</a><span class="k">def</span> <span class="nf">flag_not_None_items</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">item</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_</span><span class="p">]</span></div>


<div class="viewcode-block" id="scalar_input_map"><a class="viewcode-back" href="../../utool.html#utool.util_list.scalar_input_map">[docs]</a><span class="k">def</span> <span class="nf">scalar_input_map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">input_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map like function</span>

<span class="sd">    Args:</span>
<span class="sd">        func: function to apply</span>
<span class="sd">        input_ : either an iterable or scalar value</span>

<span class="sd">    Returns:</span>
<span class="sd">        If ``input_`` is iterable this function behaves like map</span>
<span class="sd">        otherwise applies func to ``input_``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">util_iter</span><span class="o">.</span><span class="n">isiterable</span><span class="p">(</span><span class="n">input_</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">input_</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">input_</span><span class="p">)</span></div>


<div class="viewcode-block" id="partial_imap_1to1"><a class="viewcode-back" href="../../utool.html#utool.util_list.partial_imap_1to1">[docs]</a><span class="k">def</span> <span class="nf">partial_imap_1to1</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">si_func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; a bit messy</span>

<span class="sd">    DEPRICATE</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@functools</span><span class="o">.</span><span class="n">wraps</span><span class="p">(</span><span class="n">si_func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="n">input_</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">util_iter</span><span class="o">.</span><span class="n">isiterable</span><span class="p">(</span><span class="n">input_</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">si_func</span><span class="p">(</span><span class="n">input_</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">si_func</span><span class="p">(</span><span class="n">input_</span><span class="p">)))</span>

    <span class="n">set_funcname</span><span class="p">(</span>
        <span class="n">wrapper</span><span class="p">,</span> <span class="n">util_str</span><span class="o">.</span><span class="n">get_callable_name</span><span class="p">(</span><span class="n">func</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;_mapper_&#39;</span> <span class="o">+</span> <span class="n">get_funcname</span><span class="p">(</span><span class="n">si_func</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span></div>


<div class="viewcode-block" id="sample_zip"><a class="viewcode-back" href="../../utool.html#utool.util_list.sample_zip">[docs]</a><span class="k">def</span> <span class="nf">sample_zip</span><span class="p">(</span><span class="n">items_list</span><span class="p">,</span> <span class="n">num_samples</span><span class="p">,</span> <span class="n">allow_overflow</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">per_bin</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Helper for sampling</span>

<span class="sd">    Given a list of lists, samples one item for each list and bins them into</span>
<span class="sd">    num_samples bins. If all sublists are of equal size this is equivilent to a</span>
<span class="sd">    zip, but otherewise consecutive bins will have monotonically less</span>
<span class="sd">    elemements</span>

<span class="sd">    # Doctest doesn&#39;t work with assertionerror</span>
<span class="sd">    #util_list.sample_zip(items_list, 2)</span>
<span class="sd">    #...</span>
<span class="sd">    #AssertionError: Overflow occured</span>

<span class="sd">    Args:</span>
<span class="sd">        items_list (list):</span>
<span class="sd">        num_samples (?):</span>
<span class="sd">        allow_overflow (bool):</span>
<span class="sd">        per_bin (int):</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple : (samples_list, overflow_samples)</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool import util_list</span>
<span class="sd">        &gt;&gt;&gt; items_list = [[1, 2, 3, 4, 0], [5, 6, 7], [], [8, 9], [10]]</span>
<span class="sd">        &gt;&gt;&gt; util_list.sample_zip(items_list, 5)</span>
<span class="sd">        ...</span>
<span class="sd">        [[1, 5, 8, 10], [2, 6, 9], [3, 7], [4], [0]]</span>
<span class="sd">        &gt;&gt;&gt; util_list.sample_zip(items_list, 2, allow_overflow=True)</span>
<span class="sd">        ...</span>
<span class="sd">        ([[1, 5, 8, 10], [2, 6, 9]], [3, 7, 4])</span>
<span class="sd">        &gt;&gt;&gt; util_list.sample_zip(items_list, 4, allow_overflow=True, per_bin=2)</span>
<span class="sd">        ...</span>
<span class="sd">        ([[1, 5, 8, 10, 2, 6, 9], [3, 7, 4], [], []], [0])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Prealloc a list of lists</span>
    <span class="n">samples_list</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)]</span>
    <span class="c1"># Sample the ix-th value from every list</span>
    <span class="n">samples_iter</span> <span class="o">=</span> <span class="n">zip_longest</span><span class="p">(</span><span class="o">*</span><span class="n">items_list</span><span class="p">)</span>
    <span class="n">sx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">samples_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_samples</span><span class="p">),</span> <span class="n">samples_iter</span><span class="p">):</span>
        <span class="n">samples</span> <span class="o">=</span> <span class="n">filter_Nones</span><span class="p">(</span><span class="n">samples_</span><span class="p">)</span>
        <span class="n">samples_list</span><span class="p">[</span><span class="n">sx</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        <span class="c1"># Put per_bin from each sublist into a sample</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">per_bin</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Check for overflow</span>
    <span class="k">if</span> <span class="n">allow_overflow</span><span class="p">:</span>
        <span class="n">overflow_samples</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">([</span><span class="n">filter_Nones</span><span class="p">(</span><span class="n">samples_</span><span class="p">)</span> <span class="k">for</span> <span class="n">samples_</span> <span class="ow">in</span> <span class="n">samples_iter</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">samples_list</span><span class="p">,</span> <span class="n">overflow_samples</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">samples_iter</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;Overflow occured&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">samples_list</span></div>


<div class="viewcode-block" id="sample_lists"><a class="viewcode-back" href="../../utool.html#utool.util_list.sample_lists">[docs]</a><span class="k">def</span> <span class="nf">sample_lists</span><span class="p">(</span><span class="n">items_list</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        items_list (list):</span>
<span class="sd">        num (int): (default = 1)</span>
<span class="sd">        seed (None): (default = None)</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: samples_list</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --exec-sample_lists</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; items_list = [[], [1, 2, 3], [4], [5, 6], [7, 8, 9, 10]]</span>
<span class="sd">        &gt;&gt;&gt; num = 2</span>
<span class="sd">        &gt;&gt;&gt; seed = 0</span>
<span class="sd">        &gt;&gt;&gt; samples_list = sample_lists(items_list, num, seed)</span>
<span class="sd">        &gt;&gt;&gt; result = (&#39;samples_list = %s&#39; % (str(samples_list),))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        samples_list = [[], [3, 2], [4], [5, 6], [10, 9]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span>

    <span class="k">def</span> <span class="nf">random_choice</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">),</span> <span class="n">num</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rng</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="n">samples_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">random_choice</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">num</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">[]</span> <span class="k">for</span> <span class="n">items</span> <span class="ow">in</span> <span class="n">items_list</span>
    <span class="p">]</span>
    <span class="k">return</span> <span class="n">samples_list</span></div>


<div class="viewcode-block" id="strided_sample"><a class="viewcode-back" href="../../utool.html#utool.util_list.strided_sample">[docs]</a><span class="k">def</span> <span class="nf">strided_sample</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; # build test data</span>
<span class="sd">        &gt;&gt;&gt; items = [1, 2, 3, 4, 5]</span>
<span class="sd">        &gt;&gt;&gt; num = 3</span>
<span class="sd">        &gt;&gt;&gt; offset = 0</span>
<span class="sd">        &gt;&gt;&gt; # execute function</span>
<span class="sd">        &gt;&gt;&gt; sample_items = strided_sample(items, num, offset)</span>
<span class="sd">        &gt;&gt;&gt; # verify results</span>
<span class="sd">        &gt;&gt;&gt; result = str(sample_items)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">math</span>

    <span class="n">stride</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">/</span> <span class="n">num</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">sample_items</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="n">offset</span><span class="p">::</span><span class="n">stride</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">sample_items</span></div>


<div class="viewcode-block" id="issorted"><a class="viewcode-back" href="../../utool.html#utool.util_list.issorted">[docs]</a><span class="k">def</span> <span class="nf">issorted</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="n">operator</span><span class="o">.</span><span class="n">le</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines if a list is sorted</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (list):</span>
<span class="sd">        op (func): sorted operation (default=operator.le)</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool : True if the list is sorted</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">op</span><span class="p">(</span><span class="n">list_</span><span class="p">[</span><span class="n">ix</span><span class="p">],</span> <span class="n">list_</span><span class="p">[</span><span class="n">ix</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span></div>


<div class="viewcode-block" id="find_nonconsec_values"><a class="viewcode-back" href="../../utool.html#utool.util_list.find_nonconsec_values">[docs]</a><span class="k">def</span> <span class="nf">find_nonconsec_values</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">min_</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determines if a list of values is consecutive (ascending)</span>

<span class="sd">    Args:</span>
<span class="sd">        values (list): list of values, sorted and unique</span>
<span class="sd">        min_(int): minimum value in range defaults min(values)</span>
<span class="sd">        max_(int): maximum value in range defaults max(values)</span>

<span class="sd">    Returns:</span>
<span class="sd">        missing_values: missing values that would make the list consecutive</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-find_nonconsec_values</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; values = np.array([-2, 1,  2, 10])</span>
<span class="sd">        &gt;&gt;&gt; result = find_nonconsec_values(values)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [-1, 0, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># values = sorted(set(values))</span>
    <span class="k">if</span> <span class="n">min_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">min_</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">max_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">max_</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">valx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">missing_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">check</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">min_</span><span class="p">,</span> <span class="n">max_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">values</span><span class="p">[</span><span class="n">valx</span><span class="p">]</span> <span class="o">!=</span> <span class="n">check</span><span class="p">:</span>
            <span class="n">missing_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">check</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">valx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">missing_values</span></div>


<div class="viewcode-block" id="group_consecutives"><a class="viewcode-back" href="../../utool.html#utool.util_list.group_consecutives">[docs]</a><span class="k">def</span> <span class="nf">group_consecutives</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return list of consecutive lists of numbers from data (number list).</span>

<span class="sd">    References:</span>
<span class="sd">        http://stackoverflow.com/questions/7352684/how-to-find-the-groups-of-consecutive-elements-from-an-array-in-numpy</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">run</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">run</span><span class="p">]</span>
    <span class="n">expect</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">item</span> <span class="o">==</span> <span class="n">expect</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">expect</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">run</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">run</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">]</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">run</span><span class="p">)</span>
        <span class="n">expect</span> <span class="o">=</span> <span class="n">item</span> <span class="o">+</span> <span class="n">stepsize</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="group_consecutives_numpy"><a class="viewcode-back" href="../../utool.html#utool.util_list.group_consecutives_numpy">[docs]</a><span class="k">def</span> <span class="nf">group_consecutives_numpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">stepsize</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        data (?):</span>
<span class="sd">        stepsize (int):</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: list of ndarrays</span>

<span class="sd">    References:</span>
<span class="sd">        http://stackoverflow.com/questions/7352684/how-to-find-the-groups-of-consecutive-elements-from-an-array-in-numpy</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-group_consecutives</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; # build test data</span>
<span class="sd">        &gt;&gt;&gt; data = np.array([  0,   1,   2,   3,   4, 320, 636, 637, 638, 639])</span>
<span class="sd">        &gt;&gt;&gt; stepsize = 1</span>
<span class="sd">        &gt;&gt;&gt; # execute function</span>
<span class="sd">        &gt;&gt;&gt; result = group_consecutives(data, stepsize)</span>
<span class="sd">        &gt;&gt;&gt; # verify results</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [array([0, 1, 2, 3, 4]), array([320]), array([636, 637, 638, 639])]</span>

<span class="sd">    Timeit::</span>
<span class="sd">        %timeit group_consecutives_numpy(data, stepsize) #  14.8 µs per loop</span>
<span class="sd">        %timeit group_consecutives(data, stepsize) # 4.47 µs per loop</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">!=</span> <span class="n">stepsize</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="debug_consec_list"><a class="viewcode-back" href="../../utool.html#utool.util_list.debug_consec_list">[docs]</a><span class="k">def</span> <span class="nf">debug_consec_list</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns:</span>
<span class="sd">        tuple of (missing_items, missing_indices, duplicate_items)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">issorted</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;warning list is not sorted. indices will not match&#39;</span><span class="p">)</span>
    <span class="n">sortedlist</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">sortedlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">missing_vals</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">missing_indices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">duplicate_items</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sortedlist</span><span class="p">):</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">item</span> <span class="o">-</span> <span class="n">last</span>
        <span class="k">if</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">missing_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">miss</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">last</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">last</span> <span class="o">+</span> <span class="n">diff</span><span class="p">):</span>
                <span class="n">missing_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">miss</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">diff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">duplicate_items</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">diff</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Expected case</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s1">&#39;We sorted the list. diff can not be negative&#39;</span><span class="p">)</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">item</span>
    <span class="k">return</span> <span class="n">missing_vals</span><span class="p">,</span> <span class="n">missing_indices</span><span class="p">,</span> <span class="n">duplicate_items</span></div>


<div class="viewcode-block" id="find_duplicate_items"><a class="viewcode-back" href="../../utool.html#utool.util_list.find_duplicate_items">[docs]</a><span class="k">def</span> <span class="nf">find_duplicate_items</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        items (list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: duplicate_map of indexes</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-find_duplicate_items</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; items = [0, 1, 2, 3, 3, 0, 12, 2, 9]</span>
<span class="sd">        &gt;&gt;&gt; duplicate_map = find_duplicate_items(items)</span>
<span class="sd">        &gt;&gt;&gt; result = str(duplicate_map)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="c1"># Build item histogram</span>
    <span class="n">duplicate_map</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">ddict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">count</span><span class="p">,</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
        <span class="n">duplicate_map</span><span class="p">[</span><span class="n">item</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">count</span><span class="p">)</span>
    <span class="c1"># remove singleton items</span>
    <span class="n">singleton_keys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">(</span><span class="n">duplicate_map</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">duplicate_map</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">singleton_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">singleton_keys</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">duplicate_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="n">duplicate_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">duplicate_map</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">duplicate_map</span></div>


<span class="c1"># get_non_consecutive_positions = debug_consec_list</span>


<div class="viewcode-block" id="duplicates_exist"><a class="viewcode-back" href="../../utool.html#utool.util_list.duplicates_exist">[docs]</a><span class="k">def</span> <span class="nf">duplicates_exist</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; returns if list has duplicates &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">items</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="isunique"><a class="viewcode-back" href="../../utool.html#utool.util_list.isunique">[docs]</a><span class="k">def</span> <span class="nf">isunique</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="n">duplicates_exist</span><span class="p">(</span><span class="n">items</span><span class="p">)</span></div>


<div class="viewcode-block" id="print_duplicate_map"><a class="viewcode-back" href="../../utool.html#utool.util_list.print_duplicate_map">[docs]</a><span class="k">def</span> <span class="nf">print_duplicate_map</span><span class="p">(</span><span class="n">duplicate_map</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># args are corresponding lists</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">printfn</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;printfn&#39;</span><span class="p">,</span> <span class="nb">print</span><span class="p">)</span>
    <span class="n">printfn</span><span class="p">(</span><span class="s1">&#39;There are </span><span class="si">%d</span><span class="s1"> duplicates&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">duplicate_map</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">index_list</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">duplicate_map</span><span class="p">):</span>
        <span class="n">printfn</span><span class="p">(</span>
            <span class="s1">&#39;item=</span><span class="si">%s</span><span class="s1"> appears </span><span class="si">%d</span><span class="s1"> times at indices: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_list</span><span class="p">),</span> <span class="n">index_list</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">argx</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="c1"># argname = &#39;arg%d&#39; % (argx)</span>
            <span class="n">argname</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">get_varname_from_stack</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">:</span>
                <span class="n">printfn</span><span class="p">(</span><span class="s1">&#39; * </span><span class="si">%s</span><span class="s1">[</span><span class="si">%d</span><span class="s1">] = </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">argname</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">arg</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span>
    <span class="k">return</span> <span class="n">duplicate_map</span></div>


<div class="viewcode-block" id="debug_duplicate_items"><a class="viewcode-back" href="../../utool.html#utool.util_list.debug_duplicate_items">[docs]</a><span class="k">def</span> <span class="nf">debug_duplicate_items</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">pad_stdout</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;pad_stdout&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pad_stdout</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="n">varname</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">get_varname_from_locals</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">ut</span><span class="o">.</span><span class="n">get_parent_frame</span><span class="p">()</span><span class="o">.</span><span class="n">f_locals</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[util_list] +--- DEBUG DUPLICATE ITEMS  </span><span class="si">%r</span><span class="s1"> ---&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">varname</span><span class="p">,))</span>

    <span class="k">def</span> <span class="nf">printfn</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[util_list] |&#39;</span> <span class="o">+</span> <span class="n">msg</span><span class="p">)</span>

    <span class="c1"># with ut.Indenter(&#39;[util_list] | &#39;):</span>
    <span class="n">duplicate_map</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">find_duplicate_items</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
    <span class="n">printkw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;printfn&#39;</span><span class="p">:</span> <span class="n">printfn</span><span class="p">}</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">print_duplicate_map</span><span class="p">(</span><span class="n">duplicate_map</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">printkw</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[util_list] L--- FINISH DEBUG DUPLICATE ITEMS ---&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pad_stdout</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">duplicate_map</span></div>


<div class="viewcode-block" id="list_depth"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_depth">[docs]</a><span class="k">def</span> <span class="nf">list_depth</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span> <span class="n">_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the deepest level of nesting within a list of lists</span>

<span class="sd">    Args:</span>
<span class="sd">       list_  : a nested listlike object</span>
<span class="sd">       func   : depth aggregation strategy (defaults to max)</span>
<span class="sd">       _depth : internal var</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list_ = [[[[[1]]], [3]], [[1], [3]], [[1], [3]]]</span>
<span class="sd">        &gt;&gt;&gt; result = (list_depth(list_, _depth=0))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">depth_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">list_depth</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">_depth</span><span class="o">=</span><span class="n">_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_</span>
        <span class="k">if</span> <span class="n">util_type</span><span class="o">.</span><span class="n">is_listlike</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">depth_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">depth_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_depth</span></div>


<div class="viewcode-block" id="depth"><a class="viewcode-back" href="../../utool.html#utool.util_list.depth">[docs]</a><span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span> <span class="n">_depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the nesting depth of a nested sequence</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">sequence</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sequence</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">depth_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">depth</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">func</span><span class="p">,</span> <span class="n">_depth</span><span class="o">=</span><span class="n">_depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sequence</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="ow">or</span> <span class="n">util_type</span><span class="o">.</span><span class="n">is_listlike</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
    <span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">depth_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">depth_list</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_depth</span></div>


<div class="viewcode-block" id="list_deep_types"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_deep_types">[docs]</a><span class="k">def</span> <span class="nf">list_deep_types</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns all types in a deep list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">type_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">util_type</span><span class="o">.</span><span class="n">is_listlike</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="n">type_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">list_deep_types</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">type_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">type_list</span></div>


<div class="viewcode-block" id="depth_profile"><a class="viewcode-back" href="../../utool.html#utool.util_list.depth_profile">[docs]</a><span class="k">def</span> <span class="nf">depth_profile</span><span class="p">(</span>
    <span class="n">list_</span><span class="p">,</span>
    <span class="n">max_depth</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">compress_homogenous</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">compress_consecutive</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">new_depth</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a nested list corresponding the shape of the nested structures</span>
<span class="sd">    lists represent depth, tuples represent shape. The values of the items do</span>
<span class="sd">    not matter. only the lengths.</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (list):</span>
<span class="sd">        max_depth (None):</span>
<span class="sd">        compress_homogenous (bool):</span>
<span class="sd">        compress_consecutive (bool):  experimental</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-depth_profile</span>

<span class="sd">    Setup:</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>

<span class="sd">    Example0:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; list_ = [[[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]]</span>
<span class="sd">        &gt;&gt;&gt; result = depth_profile(list_)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        (2, 3, 4)</span>

<span class="sd">    Example1:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; list_ = [[[[[1]]], [3, 4, 33]], [[1], [2, 3], [4, [5, 5]]], [1, 3]]</span>
<span class="sd">        &gt;&gt;&gt; result = depth_profile(list_)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[(1, 1, 1), 3], [1, 2, [1, 2]], 2]</span>

<span class="sd">    Example2:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; list_ = [[[[[1]]], [3, 4, 33]], [[1], [2, 3], [4, [5, 5]]], [1, 3]]</span>
<span class="sd">        &gt;&gt;&gt; result = depth_profile(list_, max_depth=1)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[(1, &#39;1&#39;), 3], [1, 2, [1, &#39;2&#39;]], 2]</span>

<span class="sd">    Example3:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; list_ = [[[1, 2], [1, 2, 3]], None]</span>
<span class="sd">        &gt;&gt;&gt; result = depth_profile(list_, compress_homogenous=True)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[2, 3], 1]</span>

<span class="sd">    Example4:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; list_ = [[3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [3, 2], [9, 5, 3], [2, 2]]</span>
<span class="sd">        &gt;&gt;&gt; result = depth_profile(list_, compress_homogenous=True, compress_consecutive=True)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [2] * 6 + [3, 2]</span>

<span class="sd">    Example5:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; list_ = [[[3, 9], 2], [[3, 9], 2], [[3, 9], 2], [[3, 9], 2]]  #, [3, 2], [3, 2]]</span>
<span class="sd">        &gt;&gt;&gt; result = depth_profile(list_, compress_homogenous=True, compress_consecutive=True)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        (4, [2, 1])</span>

<span class="sd">    Example6:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; list_ = [[[[1, 2]], [1, 2]], [[[1, 2]], [1, 2]], [[[0, 2]], [1]]]</span>
<span class="sd">        &gt;&gt;&gt; result1 = depth_profile(list_, compress_homogenous=True, compress_consecutive=False)</span>
<span class="sd">        &gt;&gt;&gt; result2 = depth_profile(list_, compress_homogenous=True, compress_consecutive=True)</span>
<span class="sd">        &gt;&gt;&gt; result = str(result1) + &#39;\n&#39; + str(result2)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[(1, 2), 2], [(1, 2), 2], [(1, 2), 1]]</span>
<span class="sd">        [[(1, 2), 2]] * 2 + [[(1, 2), 1]]</span>

<span class="sd">    Example7:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; list_ = [[{&#39;a&#39;: [1, 2], &#39;b&#39;: [3, 4, 5]}, [1, 2, 3]], None]</span>
<span class="sd">        &gt;&gt;&gt; result = depth_profile(list_, compress_homogenous=True)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>

<span class="sd">    Example8:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; list_ = [[[1]], [[[1, 1], [1, 1]]], [[[[1, 3], 1], [[1, 3, 3], 1, 1]]]]</span>
<span class="sd">        &gt;&gt;&gt; result = depth_profile(list_, compress_homogenous=True)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>

<span class="sd">    Example9:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; list_ = []</span>
<span class="sd">        &gt;&gt;&gt; result = depth_profile(list_)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>

<span class="sd">        # THIS IS AN ERROR???</span>
<span class="sd">        SHOULD BE</span>
<span class="sd">        #[1, 1], [1, 2, 2], (1, ([1, 2]), (</span>

<span class="sd">    Example10:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; fm1 = [[0, 0], [0, 0]]</span>
<span class="sd">        &gt;&gt;&gt; fm2 = [[0, 0], [0, 0], [0, 0]]</span>
<span class="sd">        &gt;&gt;&gt; fm3 = [[0, 0], [0, 0], [0, 0], [0, 0]]</span>
<span class="sd">        &gt;&gt;&gt; list_ = [0, 0, 0]</span>
<span class="sd">        &gt;&gt;&gt; list_ = [fm1, fm2, fm3]</span>
<span class="sd">        &gt;&gt;&gt; max_depth = 0</span>
<span class="sd">        &gt;&gt;&gt; new_depth = True</span>
<span class="sd">        &gt;&gt;&gt; result = depth_profile(list_, max_depth=max_depth, new_depth=new_depth)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">list_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">list_</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>  <span class="c1"># handle dict</span>
    <span class="n">level_shape_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># For a pure bottom level list return the length</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">util_type</span><span class="o">.</span><span class="n">is_listlike</span><span class="p">,</span> <span class="n">list_</span><span class="p">)):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span>

    <span class="k">if</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">new_depth</span><span class="p">:</span>
        <span class="k">pass</span>
        <span class="c1"># max_depth_ = None if max_depth is None else max_depth - 1</span>
        <span class="c1"># if max_depth_ is None or max_depth_ &gt; 0:</span>
        <span class="c1">#     pass</span>
        <span class="c1"># else:</span>
        <span class="c1">#     for item in list_:</span>
        <span class="c1">#         if isinstance(item, dict):</span>
        <span class="c1">#             item = list(item.values())  # handle dict</span>
        <span class="c1">#         if util_type.is_listlike(item):</span>
        <span class="c1">#             if max_depth is None:</span>
        <span class="c1">#                 level_shape_list.append(depth_profile(item, None))</span>
        <span class="c1">#             else:</span>
        <span class="c1">#                 if max_depth &gt;= 0:</span>
        <span class="c1">#                     level_shape_list.append(depth_profile(item, max_depth - 1))</span>
        <span class="c1">#                 else:</span>
        <span class="c1">#                     level_shape_list.append(str(len(item)))</span>
        <span class="c1">#         else:</span>
        <span class="c1">#             level_shape_list.append(1)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">item</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>  <span class="c1"># handle dict</span>
            <span class="k">if</span> <span class="n">util_type</span><span class="o">.</span><span class="n">is_listlike</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">max_depth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">level_shape_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">depth_profile</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">max_depth</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">level_shape_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">depth_profile</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">max_depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">level_shape_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">level_shape_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">compress_homogenous</span><span class="p">:</span>
        <span class="c1"># removes redudant information by returning a shape duple</span>
        <span class="k">if</span> <span class="n">allsame</span><span class="p">(</span><span class="n">level_shape_list</span><span class="p">):</span>
            <span class="n">dim_</span> <span class="o">=</span> <span class="n">level_shape_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">len_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">level_shape_list</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim_</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">level_shape_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">len_</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">dim_</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">level_shape_list</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">len_</span><span class="p">,</span> <span class="n">dim_</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">compress_consecutive</span><span class="p">:</span>
        <span class="n">hash_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">hash</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">level_shape_list</span><span class="p">)))</span>
        <span class="n">consec_list</span> <span class="o">=</span> <span class="n">group_consecutives</span><span class="p">(</span><span class="n">hash_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">consec_list</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">level_shape_list</span><span class="p">):</span>
            <span class="n">len_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">consec_list</span><span class="p">))</span>
            <span class="n">cumsum_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">len_list</span><span class="p">)</span>
            <span class="n">consec_str</span> <span class="o">=</span> <span class="s1">&#39;[&#39;</span>
            <span class="n">thresh</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">len_</span><span class="p">,</span> <span class="n">cumsum</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">len_list</span><span class="p">,</span> <span class="n">cumsum_list</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">level_shape_list</span><span class="p">[</span><span class="n">cumsum</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">len_</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">:</span>
                    <span class="n">consec_str</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;] * &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">len_</span><span class="p">)</span>
                    <span class="n">consec_str</span> <span class="o">+=</span> <span class="s1">&#39; + [&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">consec_str</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span>
            <span class="k">if</span> <span class="n">consec_str</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;, &#39;</span><span class="p">):</span>
                <span class="n">consec_str</span> <span class="o">=</span> <span class="n">consec_str</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
                <span class="c1"># consec_str += &#39;]&#39;</span>
            <span class="c1"># consec_str = consec_str.rstrip(&#39;, &#39;).rstrip(&#39;]&#39;)</span>
            <span class="c1"># consec_str = consec_str.rstrip(&#39;, &#39;)</span>
            <span class="c1"># if consec_str.endswith(&#39;]&#39;):</span>
            <span class="c1">#    consec_str = consec_str[:-1]</span>
            <span class="n">consec_str</span> <span class="o">+=</span> <span class="s1">&#39;]&#39;</span>
            <span class="n">level_shape_list</span> <span class="o">=</span> <span class="n">consec_str</span>
    <span class="k">return</span> <span class="n">level_shape_list</span></div>


<div class="viewcode-block" id="list_type"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_type">[docs]</a><span class="k">def</span> <span class="nf">list_type</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
    <span class="n">types</span> <span class="o">=</span> <span class="n">unique_ordered</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">list_</span><span class="p">)))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">types</span></div>


<div class="viewcode-block" id="list_type_profile"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_type_profile">[docs]</a><span class="k">def</span> <span class="nf">list_type_profile</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">compress_homogenous</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">with_dtype</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    similar to depth_profile but reports types</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence (?):</span>
<span class="sd">        compress_homogenous (bool): (default = True)</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: level_type_str</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-list_type_profile</span>
<span class="sd">        python3 -m utool.util_list --test-list_type_profile</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; sequence = [[1, 2], np.array([1, 2, 3], dtype=np.int32), (np.array([1, 2, 3], dtype=np.int32),)]</span>
<span class="sd">        &gt;&gt;&gt; compress_homogenous = True</span>
<span class="sd">        &gt;&gt;&gt; level_type_str = list_type_profile(sequence, compress_homogenous)</span>
<span class="sd">        &gt;&gt;&gt; result = (&#39;level_type_str = %s&#39; % (str(level_type_str),))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        level_type_str = list(list(int*2), ndarray[int32], tuple(ndarray[int32]*1))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># For a pure bottom level list return the length</span>
    <span class="c1"># if not any(map(util_type.is_listlike, sequence)) or (isinstance(sequence, np.ndarray) and sequence.dtype != object):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">util_type</span><span class="o">.</span><span class="n">is_listlike</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sequence</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">object</span>
    <span class="p">):</span>
        <span class="n">typename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">sequence</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&lt;type &#39;&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
            <span class="n">typename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">sequence</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&lt;class &#39;&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">with_dtype</span> <span class="ow">and</span> <span class="n">typename</span> <span class="o">==</span> <span class="s1">&#39;numpy.ndarray&#39;</span><span class="p">:</span>
            <span class="n">typename</span> <span class="o">=</span> <span class="n">typename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;numpy.&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">typename</span> <span class="o">+=</span> <span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sequence</span><span class="o">.</span><span class="n">dtype</span><span class="p">,)</span>

        <span class="n">level_type_str</span> <span class="o">=</span> <span class="n">typename</span>
        <span class="k">return</span> <span class="n">level_type_str</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span>

    <span class="n">level_type_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
        <span class="c1"># if util_type.is_listlike(item):</span>
        <span class="n">item_type_profile</span> <span class="o">=</span> <span class="n">list_type_profile</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">with_dtype</span><span class="o">=</span><span class="n">with_dtype</span><span class="p">)</span>
        <span class="n">level_type_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item_type_profile</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">compress_homogenous</span><span class="p">:</span>
        <span class="c1"># removes redudant information by returning a type and number</span>
        <span class="k">if</span> <span class="n">allsame</span><span class="p">(</span><span class="n">level_type_list</span><span class="p">):</span>
            <span class="n">type_</span> <span class="o">=</span> <span class="n">level_type_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">level_type_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">type_</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;*&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">level_type_list</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">level_type_str</span> <span class="o">=</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">level_type_list</span><span class="p">)</span>
    <span class="n">typename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">sequence</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&lt;type &#39;&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
        <span class="n">typename</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">sequence</span><span class="p">))</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&lt;class &#39;&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">level_type_str</span> <span class="o">=</span> <span class="n">typename</span> <span class="o">+</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">level_type_str</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>
    <span class="k">return</span> <span class="n">level_type_str</span></div>


<div class="viewcode-block" id="type_profile2"><a class="viewcode-back" href="../../utool.html#utool.util_list.type_profile2">[docs]</a><span class="k">def</span> <span class="nf">type_profile2</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">TypedSequence</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    similar to depth_profile but reports types</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence (?):</span>
<span class="sd">        compress_homogenous (bool): (default = True)</span>

<span class="sd">    Returns:</span>
<span class="sd">        str: level_type_str</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --exec-type_profile2</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; sequence = []</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; self = typeprof = type_profile2(sequence, type_sequence_factory())</span>
<span class="sd">        &gt;&gt;&gt; result = (&#39;level_type_str = %s&#39; % (str(level_type_str),))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">TypedSequence</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">TypedSequence</span> <span class="o">=</span> <span class="n">type_sequence_factory</span><span class="p">()</span>
    <span class="c1"># For a pure bottom level list return the length</span>
    <span class="c1"># if not any(map(util_type.is_listlike, sequence)) or (isinstance(sequence, np.ndarray) and sequence.dtype != object):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">util_type</span><span class="o">.</span><span class="n">is_listlike</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
        <span class="nb">isinstance</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sequence</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="nb">object</span>
    <span class="p">):</span>
        <span class="c1"># Scalar / ndarray type</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;numpy.ndarray&#39;</span><span class="p">:</span>
            <span class="n">subtype_list</span> <span class="o">=</span> <span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sequence</span><span class="o">.</span><span class="n">dtype</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subtype_list</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">TypedSequence</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">sequence</span><span class="p">),</span> <span class="n">subtype_list</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">util_type</span><span class="o">.</span><span class="n">is_listlike</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
        <span class="c1"># Sequence type</span>
        <span class="n">sequence_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>

        <span class="n">subtype_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
            <span class="n">item_type_profile</span> <span class="o">=</span> <span class="n">type_profile2</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">TypedSequence</span><span class="o">=</span><span class="n">TypedSequence</span><span class="p">)</span>
            <span class="n">subtype_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item_type_profile</span><span class="p">)</span>
        <span class="n">sequence_type_profile</span> <span class="o">=</span> <span class="n">TypedSequence</span><span class="p">(</span><span class="n">sequence_type</span><span class="p">,</span> <span class="n">subtype_list</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sequence_type_profile</span></div>
        <span class="c1"># level_type_str = typename + &#39;(&#39; + str(level_type_str) + &#39;)&#39;</span>
        <span class="c1"># return level_type_str</span>


<div class="viewcode-block" id="type_sequence_factory"><a class="viewcode-back" href="../../utool.html#utool.util_list.type_sequence_factory">[docs]</a><span class="k">def</span> <span class="nf">type_sequence_factory</span><span class="p">():</span>
    <span class="kn">from</span> <span class="nn">utool</span> <span class="k">import</span> <span class="n">util_dev</span>

    <span class="k">class</span> <span class="nc">TypedSequence</span><span class="p">(</span><span class="n">util_dev</span><span class="o">.</span><span class="n">NiceRepr</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type_</span><span class="p">,</span> <span class="n">subtype_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type_</span> <span class="o">=</span> <span class="n">type_</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">subtype_list</span> <span class="o">=</span> <span class="n">subtype_list</span>

        <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">type_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type_</span><span class="p">)</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="n">type_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&gt;&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="n">type_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&lt;type &#39;&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="n">type_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&lt;class &#39;&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="n">type_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;numpy.&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">type_str</span>

        <span class="k">def</span> <span class="nf">subtype_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtype_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;&#39;</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subtype_list</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtype_list</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">grouped</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">group</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtype_list</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="n">prev</span> <span class="ow">or</span> <span class="n">prev</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">grouped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                        <span class="n">group</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">]</span>
                    <span class="n">prev</span> <span class="o">=</span> <span class="n">item</span>
                <span class="n">grouped</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grouped</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">subtype_list</span><span class="p">):</span>
                    <span class="n">toret</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s1">&#39;(&#39;</span>
                        <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">sub</span><span class="o">.</span><span class="n">__nice__</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtype_list</span><span class="p">])</span>
                        <span class="o">+</span> <span class="s1">&#39;)&#39;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">compressed_types</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take_column</span><span class="p">(</span><span class="n">grouped</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">compressed_lens</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">lmap</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">grouped</span><span class="p">)</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="n">compressed_types</span><span class="p">,</span> <span class="n">compressed_lens</span><span class="p">)</span>
                    <span class="n">groupstrs</span> <span class="o">=</span> <span class="p">[</span>
                        <span class="n">sub</span><span class="o">.</span><span class="n">__nice__</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="s1">&#39;*&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">1</span>
                        <span class="k">else</span> <span class="n">sub</span><span class="o">.</span><span class="n">__nice__</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>
                        <span class="k">for</span> <span class="n">sub</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">compressed_types</span><span class="p">,</span> <span class="n">compressed_lens</span><span class="p">)</span>
                    <span class="p">]</span>
                    <span class="n">toret</span> <span class="o">=</span> <span class="s1">&#39;(&#39;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">groupstrs</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>
                <span class="k">return</span> <span class="n">toret</span>

        <span class="k">def</span> <span class="nf">__nice__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">type_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_str</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtype_list</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">type_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">subtype_str</span><span class="p">()</span>
            <span class="k">return</span> <span class="s1">&#39; &#39;</span> <span class="o">+</span> <span class="n">type_str</span>

    <span class="k">return</span> <span class="n">TypedSequence</span></div>


<span class="n">type_profile</span> <span class="o">=</span> <span class="n">list_type_profile</span>


<div class="viewcode-block" id="list_cover"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_cover">[docs]</a><span class="k">def</span> <span class="nf">list_cover</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns boolean for each position in list1 if it is in list2</span>

<span class="sd">    Args:</span>
<span class="sd">        list1 (list):</span>
<span class="sd">        list2 (list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: incover_list - true where list1 intersects list2</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-list_cover</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; # build test data</span>
<span class="sd">        &gt;&gt;&gt; list1 = [1, 2, 3, 4, 5, 6]</span>
<span class="sd">        &gt;&gt;&gt; list2 = [2, 3, 6]</span>
<span class="sd">        &gt;&gt;&gt; # execute function</span>
<span class="sd">        &gt;&gt;&gt; incover_list = list_cover(list1, list2)</span>
<span class="sd">        &gt;&gt;&gt; # verify results</span>
<span class="sd">        &gt;&gt;&gt; result = str(incover_list)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [False, True, True, False, False, True]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">set2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">list2</span><span class="p">)</span>
    <span class="n">incover_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">item1</span> <span class="ow">in</span> <span class="n">set2</span> <span class="k">for</span> <span class="n">item1</span> <span class="ow">in</span> <span class="n">list1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">incover_list</span></div>


<div class="viewcode-block" id="and_lists"><a class="viewcode-back" href="../../utool.html#utool.util_list.and_lists">[docs]</a><span class="k">def</span> <span class="nf">and_lists</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="c1"># [all(tup) for tup in zip(*args)]</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">util_iter</span><span class="o">.</span><span class="n">and_iters</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span></div>


<div class="viewcode-block" id="xor_lists"><a class="viewcode-back" href="../../utool.html#utool.util_list.xor_lists">[docs]</a><span class="k">def</span> <span class="nf">xor_lists</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns:</span>
<span class="sd">        list:</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-xor_lists</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; args = ([True, False, False, True], [True, True, False, False])</span>
<span class="sd">        &gt;&gt;&gt; result = xor_lists(*args)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [False, True, False, True]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">xor</span><span class="p">,</span> <span class="n">tup</span><span class="p">)</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)]</span></div>


<div class="viewcode-block" id="not_list"><a class="viewcode-back" href="../../utool.html#utool.util_list.not_list">[docs]</a><span class="k">def</span> <span class="nf">not_list</span><span class="p">(</span><span class="n">flag_list</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="ow">not</span> <span class="n">flag</span> <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">flag_list</span><span class="p">]</span></div>


<div class="viewcode-block" id="or_lists"><a class="viewcode-back" href="../../utool.html#utool.util_list.or_lists">[docs]</a><span class="k">def</span> <span class="nf">or_lists</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">any</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span> <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)]</span></div>


<div class="viewcode-block" id="make_sortby_func"><a class="viewcode-back" href="../../utool.html#utool.util_list.make_sortby_func">[docs]</a><span class="k">def</span> <span class="nf">make_sortby_func</span><span class="p">(</span><span class="n">item_list</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="n">sortxs_</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">item_list</span><span class="p">)</span>
    <span class="n">sortxs</span> <span class="o">=</span> <span class="n">sortxs_</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">reverse</span> <span class="k">else</span> <span class="n">sortxs_</span>

    <span class="k">def</span> <span class="nf">sortby_func</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">take</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">sortxs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sortby_func</span></div>


<div class="viewcode-block" id="filter_startswith"><a class="viewcode-back" href="../../utool.html#utool.util_list.filter_startswith">[docs]</a><span class="k">def</span> <span class="nf">filter_startswith</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">str_</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">item_startswith</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">str_</span><span class="p">)</span>

    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">item_startswith</span><span class="p">,</span> <span class="n">list_</span><span class="p">))</span></div>


<div class="viewcode-block" id="list_roll"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_roll">[docs]</a><span class="k">def</span> <span class="nf">list_roll</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Like numpy.roll for python lists</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (list):</span>
<span class="sd">        n (int):</span>

<span class="sd">    Returns:</span>
<span class="sd">        list:</span>

<span class="sd">    References:</span>
<span class="sd">        http://stackoverflow.com/questions/9457832/python-list-rotation</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list_ = [1, 2, 3, 4, 5]</span>
<span class="sd">        &gt;&gt;&gt; n = 2</span>
<span class="sd">        &gt;&gt;&gt; result = list_roll(list_, n)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [4, 5, 1, 2, 3]</span>

<span class="sd">    Ignore:</span>
<span class="sd">        np.roll(list_, n)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">list_</span><span class="p">[</span><span class="o">-</span><span class="n">n</span><span class="p">:]</span> <span class="o">+</span> <span class="n">list_</span><span class="p">[:</span><span class="o">-</span><span class="n">n</span><span class="p">]</span></div>


<div class="viewcode-block" id="list_argmax"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_argmax">[docs]</a><span class="k">def</span> <span class="nf">list_argmax</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">list_</span><span class="p">))</span></div>


<div class="viewcode-block" id="list_argmaxima"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_argmaxima">[docs]</a><span class="k">def</span> <span class="nf">list_argmaxima</span><span class="p">(</span><span class="n">list_</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        list_ (list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: argmaxima</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --exec-list_argmaxima</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list_ = np.array([1, 2, 3, 3, 3, 2, 1])</span>
<span class="sd">        &gt;&gt;&gt; argmaxima = list_argmaxima(list_)</span>
<span class="sd">        &gt;&gt;&gt; result = (&#39;argmaxima = %s&#39; % (str(argmaxima),))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        argmaxima = [2 3 4]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">argmax</span> <span class="o">=</span> <span class="n">list_argmax</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span>
    <span class="n">maxval</span> <span class="o">=</span> <span class="n">list_</span><span class="p">[</span><span class="n">argmax</span><span class="p">]</span>
    <span class="n">argmaxima</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">maxval</span><span class="p">,</span> <span class="n">list_</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">argmaxima</span></div>


<div class="viewcode-block" id="make_index_lookup"><a class="viewcode-back" href="../../utool.html#utool.util_list.make_index_lookup">[docs]</a><span class="k">def</span> <span class="nf">make_index_lookup</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">dict_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        list_ (list): assumed to have unique items</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: mapping from item to index</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --exec-make_index_lookup</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; list_ = [5, 3, 8, 2]</span>
<span class="sd">        &gt;&gt;&gt; idx2_item = ut.make_index_lookup(list_)</span>
<span class="sd">        &gt;&gt;&gt; result = ut.repr2(idx2_item, nl=False)</span>
<span class="sd">        &gt;&gt;&gt; assert ut.dict_take(idx2_item, list_) == list(range(len(list_)))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        {2: 3, 3: 1, 5: 0, 8: 2}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">dict_factory</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_</span><span class="p">))))</span></div>


<div class="viewcode-block" id="list_alignment"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_alignment">[docs]</a><span class="k">def</span> <span class="nf">list_alignment</span><span class="p">(</span><span class="n">list1</span><span class="p">,</span> <span class="n">list2</span><span class="p">,</span> <span class="n">missing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assumes list items are unique</span>

<span class="sd">    Args:</span>
<span class="sd">        list1 (list): a list of unique items to be aligned</span>
<span class="sd">        list2 (list): a list of unique items in a desired ordering</span>
<span class="sd">        missing (bool): True if list2 can contain items not in list1</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: sorting that will map list1 onto list2</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list list_alignment</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; list1 = [&#39;b&#39;, &#39;c&#39;, &#39;a&#39;]</span>
<span class="sd">        &gt;&gt;&gt; list2 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span>
<span class="sd">        &gt;&gt;&gt; sortx = list_alignment(list1, list2)</span>
<span class="sd">        &gt;&gt;&gt; list1_aligned = take(list1, sortx)</span>
<span class="sd">        &gt;&gt;&gt; assert list1_aligned == list2</span>

<span class="sd">    Example1:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; list1 = [&#39;b&#39;, &#39;c&#39;, &#39;a&#39;]</span>
<span class="sd">        &gt;&gt;&gt; list2 = [&#39;a&#39;, &#39;a2&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="sd">        &gt;&gt;&gt; sortx = ut.list_alignment(list1, list2, missing=True)</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;sortx = %r&#39; % (sortx,))</span>
<span class="sd">        &gt;&gt;&gt; list1_aligned = ut.none_take(list1, sortx)</span>
<span class="sd">        &gt;&gt;&gt; result = (&#39;list1_aligned = %s&#39; % (ut.repr2(list1_aligned),))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        list1_aligned = [&#39;a&#39;, None, &#39;b&#39;, &#39;c&#39;, None]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">item1_to_idx</span> <span class="o">=</span> <span class="n">make_index_lookup</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
        <span class="n">sortx</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_take</span><span class="p">(</span><span class="n">item1_to_idx</span><span class="p">,</span> <span class="n">list2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sortx</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">item1_to_idx</span><span class="p">,</span> <span class="n">list2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sortx</span></div>


<div class="viewcode-block" id="unique_inverse"><a class="viewcode-back" href="../../utool.html#utool.util_list.unique_inverse">[docs]</a><span class="k">def</span> <span class="nf">unique_inverse</span><span class="p">(</span><span class="n">item_list</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Like np.unique(item_list, return_inverse=True)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">unique_items</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">item_list</span><span class="p">)</span>
    <span class="n">inverse</span> <span class="o">=</span> <span class="n">list_alignment</span><span class="p">(</span><span class="n">unique_items</span><span class="p">,</span> <span class="n">item_list</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">unique_items</span><span class="p">,</span> <span class="n">inverse</span></div>


<div class="viewcode-block" id="list_transpose"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_transpose">[docs]</a><span class="k">def</span> <span class="nf">list_transpose</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Swaps rows and columns.</span>
<span class="sd">    nCols should be specified if the initial list is empty.</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (list):</span>

<span class="sd">    Returns:</span>
<span class="sd">        list:</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-list_transpose</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list_ = [[1, 2], [3, 4]]</span>
<span class="sd">        &gt;&gt;&gt; result = list_transpose(list_)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [(1, 3), (2, 4)]</span>

<span class="sd">    Example1:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list_ = []</span>
<span class="sd">        &gt;&gt;&gt; result = list_transpose(list_, shape=(0, 5))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[], [], [], [], []]</span>

<span class="sd">    Example2:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list_ = [[], [], [], [], []]</span>
<span class="sd">        &gt;&gt;&gt; result = list_transpose(list_)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        []</span>

<span class="sd">    Example3:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; list_ = [[1, 2, 3], [3, 4]]</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_raises(ValueError, list_transpose, list_)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_cols_set</span> <span class="o">=</span> <span class="n">unique</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">list_</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_cols_set</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;listT does not support empty transpose without shapes&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;shape must be a 2-tuple&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_cols_set</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
        <span class="k">elif</span> <span class="n">num_cols_set</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">num_cols_set</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;inconsistent column lengths=</span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">num_cols_set</span><span class="p">,))</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">list_</span><span class="p">))</span></div>


<span class="n">listT</span> <span class="o">=</span> <span class="n">list_transpose</span>


<div class="viewcode-block" id="delete_items_by_index"><a class="viewcode-back" href="../../utool.html#utool.util_list.delete_items_by_index">[docs]</a><span class="k">def</span> <span class="nf">delete_items_by_index</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">index_list</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove items from ``list_`` at positions specified in ``index_list``</span>
<span class="sd">    The original ``list_`` is preserved if ``copy`` is True</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (list):</span>
<span class="sd">        index_list (list):</span>
<span class="sd">        copy (bool): preserves original list if True</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; list_ = [8, 1, 8, 1, 6, 6, 3, 4, 4, 5, 6]</span>
<span class="sd">        &gt;&gt;&gt; index_list = [2, -1]</span>
<span class="sd">        &gt;&gt;&gt; result = delete_items_by_index(list_, index_list)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [8, 1, 1, 6, 6, 3, 4, 4, 5]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">list_</span> <span class="o">=</span> <span class="n">list_</span><span class="p">[:]</span>
    <span class="c1"># Rectify negative indicies</span>
    <span class="n">index_list_</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">]</span>
    <span class="c1"># Remove largest indicies first</span>
    <span class="n">index_list_</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">index_list_</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">index_list_</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">list_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">list_</span></div>


<div class="viewcode-block" id="delete_list_items"><a class="viewcode-back" href="../../utool.html#utool.util_list.delete_list_items">[docs]</a><span class="k">def</span> <span class="nf">delete_list_items</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">item_list</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remove items in ``item_list`` from ``list_``.</span>
<span class="sd">    The original ``list_`` is preserved if ``copy`` is True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
        <span class="n">list_</span> <span class="o">=</span> <span class="n">list_</span><span class="p">[:]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">item_list</span><span class="p">:</span>
        <span class="n">list_</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">list_</span></div>


<div class="viewcode-block" id="unflat_map"><a class="viewcode-back" href="../../utool.html#utool.util_list.unflat_map">[docs]</a><span class="k">def</span> <span class="nf">unflat_map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">unflat_items</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Uses an wbia lookup function with a non-flat rowid list.</span>
<span class="sd">    In essence this is equivilent to [list(map(func, _items)) for _items in unflat_items].</span>
<span class="sd">    The utility of this function is that it only calls method once.</span>
<span class="sd">    This is more efficient for calls that can take a list of inputs</span>

<span class="sd">    Args:</span>
<span class="sd">        func (func): function</span>
<span class="sd">        unflat_items (list): list of rowid lists</span>

<span class="sd">    Returns:</span>
<span class="sd">        list of values: unflat_vals</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --test-unflat_map</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; vectorized = False</span>
<span class="sd">        &gt;&gt;&gt; kwargs = {}</span>
<span class="sd">        &gt;&gt;&gt; def func(x):</span>
<span class="sd">        &gt;&gt;&gt;     return x + 1</span>
<span class="sd">        &gt;&gt;&gt; unflat_items = [[], [1, 2, 3], [4, 5], [6, 7, 8, 9], [], []]</span>
<span class="sd">        &gt;&gt;&gt; unflat_vals = unflat_map(func, unflat_items)</span>
<span class="sd">        &gt;&gt;&gt; result = str(unflat_vals)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [[], [2, 3, 4], [5, 6], [7, 8, 9, 10], [], []]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="c1"># First flatten the list, and remember the original dimensions</span>
    <span class="n">flat_items</span><span class="p">,</span> <span class="n">reverse_list</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">invertible_flatten2</span><span class="p">(</span><span class="n">unflat_items</span><span class="p">)</span>
    <span class="c1"># Then preform the lookup / implicit mapping</span>
    <span class="k">if</span> <span class="n">vectorized</span><span class="p">:</span>
        <span class="c1"># func is vectorized</span>
        <span class="n">flat_vals</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">flat_items</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">flat_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">flat_items</span><span class="p">]</span>
    <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_vals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_items</span><span class="p">),</span> <span class="p">(</span>
            <span class="s1">&#39;flat lens not the same, len(flat_vals)=</span><span class="si">%d</span><span class="s1"> len(flat_items)=</span><span class="si">%d</span><span class="s1">&#39;</span>
            <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flat_vals</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_items</span><span class="p">),)</span>
        <span class="p">)</span>
    <span class="c1"># Then ut.unflatten2 the results to the original input dimensions</span>
    <span class="n">unflat_vals</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">unflatten2</span><span class="p">(</span><span class="n">flat_vals</span><span class="p">,</span> <span class="n">reverse_list</span><span class="p">)</span>
    <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">unflat_vals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">unflat_items</span><span class="p">),</span> <span class="p">(</span>
            <span class="s1">&#39;unflat lens not the same, len(unflat_vals)=</span><span class="si">%d</span><span class="s1"> len(unflat_rowids)=</span><span class="si">%d</span><span class="s1">&#39;</span>
            <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unflat_vals</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">unflat_items</span><span class="p">),)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">unflat_vals</span></div>


<div class="viewcode-block" id="unflat_vecmap"><a class="viewcode-back" href="../../utool.html#utool.util_list.unflat_vecmap">[docs]</a><span class="k">def</span> <span class="nf">unflat_vecmap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">unflat_items</span><span class="p">,</span> <span class="n">vectorized</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; unflat map for vectorized functions &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="c1"># First flatten the list, and remember the original dimensions</span>
    <span class="n">flat_items</span><span class="p">,</span> <span class="n">reverse_list</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">invertible_flatten2</span><span class="p">(</span><span class="n">unflat_items</span><span class="p">)</span>
    <span class="c1"># Then preform the lookup / implicit mapping</span>
    <span class="n">flat_vals</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">flat_items</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_vals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_items</span><span class="p">),</span> <span class="p">(</span>
            <span class="s1">&#39;flat lens not the same, len(flat_vals)=</span><span class="si">%d</span><span class="s1"> len(flat_items)=</span><span class="si">%d</span><span class="s1">&#39;</span>
            <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flat_vals</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat_items</span><span class="p">),)</span>
        <span class="p">)</span>
    <span class="c1"># Then ut.unflatten2 the results to the original input dimensions</span>
    <span class="n">unflat_vals</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">unflatten2</span><span class="p">(</span><span class="n">flat_vals</span><span class="p">,</span> <span class="n">reverse_list</span><span class="p">)</span>
    <span class="k">if</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">unflat_vals</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">unflat_items</span><span class="p">),</span> <span class="p">(</span>
            <span class="s1">&#39;unflat lens not the same, len(unflat_vals)=</span><span class="si">%d</span><span class="s1"> len(unflat_rowids)=</span><span class="si">%d</span><span class="s1">&#39;</span>
            <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">unflat_vals</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">unflat_items</span><span class="p">),)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">unflat_vals</span></div>


<div class="viewcode-block" id="list_getattr"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_getattr">[docs]</a><span class="k">def</span> <span class="nf">list_getattr</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">attrname</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">attrgetter</span><span class="p">(</span><span class="n">attrname</span><span class="p">),</span> <span class="n">list_</span><span class="p">))</span></div>


<div class="viewcode-block" id="list_reshape"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_reshape">[docs]</a><span class="k">def</span> <span class="nf">list_reshape</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">,</span> <span class="n">trail</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    reshapes leaving trailing dimnsions in front if prod(new_shape) != len(list_)</span>

<span class="sd">    Args:</span>
<span class="sd">        list_ (list):</span>
<span class="sd">        new_shape (tuple):</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: list_</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_list --exec-list_reshape --show</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; import numpy as np</span>
<span class="sd">        &gt;&gt;&gt; list_ = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]</span>
<span class="sd">        &gt;&gt;&gt; new_shape = (2, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; newlist = list_reshape(list_, new_shape)</span>
<span class="sd">        &gt;&gt;&gt; depth = ut.depth_profile(newlist)</span>
<span class="sd">        &gt;&gt;&gt; result = (&#39;list_ = %s&#39; % (ut.repr2(newlist, nl=1),))</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;depth = %r&#39; % (depth,))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        &gt;&gt;&gt; newlist2 = np.reshape(list_, depth).tolist()</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_eq(newlist, newlist2)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">trail</span><span class="p">:</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">total</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span>
    <span class="n">newlist</span> <span class="o">=</span> <span class="n">list_</span>
    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">new_shape</span><span class="p">):</span>
        <span class="n">slice_</span> <span class="o">=</span> <span class="p">(</span><span class="n">newlist</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="n">dim</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">))</span>
        <span class="n">newlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">slice_</span><span class="p">)))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">trail</span><span class="p">:</span>
        <span class="n">newlist</span> <span class="o">=</span> <span class="n">newlist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">newlist</span></div>


<div class="viewcode-block" id="index_to_boolmask"><a class="viewcode-back" href="../../utool.html#utool.util_list.index_to_boolmask">[docs]</a><span class="k">def</span> <span class="nf">index_to_boolmask</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">maxval</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a list of booleans where an item is True if its position is in</span>
<span class="sd">    `indices` otherwise it is False.</span>

<span class="sd">    Args:</span>
<span class="sd">        indices (list): list of integer indices</span>
<span class="sd">        maxval (int): length of the returned list. If not specified</span>
<span class="sd">            this is inverred from `indices`</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: mask: list of booleans. mask[idx] is True if idx in indices</span>

<span class="sd">    SeeAlso:</span>
<span class="sd">        vt.index_to_boolmask numpy version</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m vtool.other index_to_boolmask</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; indices = [0, 1, 4]</span>
<span class="sd">        &gt;&gt;&gt; maxval = 5</span>
<span class="sd">        &gt;&gt;&gt; mask = ut.index_to_boolmask(indices, maxval)</span>
<span class="sd">        &gt;&gt;&gt; assert mask == [True, True, False, False, True]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">maxval</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
        <span class="n">maxval</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">maxval</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
        <span class="n">mask</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">mask</span></div>


<span class="c1"># Aliases</span>
<span class="n">list_compress</span> <span class="o">=</span> <span class="n">compress</span>
<span class="n">list_ziptake</span> <span class="o">=</span> <span class="n">ziptake</span>
<span class="n">list_zipcompress</span> <span class="o">=</span> <span class="n">zipcompress</span>
<span class="n">list_where</span> <span class="o">=</span> <span class="n">where</span>
<span class="n">list_take</span> <span class="o">=</span> <span class="n">take</span>
<span class="n">list_argsort</span> <span class="o">=</span> <span class="n">argsort</span>
<span class="n">bzip</span> <span class="o">=</span> <span class="n">broadcast_zip</span>


<div class="viewcode-block" id="list_strip"><a class="viewcode-back" href="../../utool.html#utool.util_list.list_strip">[docs]</a><span class="k">def</span> <span class="nf">list_strip</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">to_strip</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    list_ = [1, 2, 1, 3, 1, 1]</span>
<span class="sd">    to_strip = 1</span>
<span class="sd">    stripped_list = ut.list_strip(list_, to_strip)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">flags</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="o">!=</span> <span class="n">to_strip</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_</span><span class="p">]</span>
    <span class="n">flag_lists</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">right</span><span class="p">:</span>
        <span class="n">rstrip_flags</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">flags</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">flag_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rstrip_flags</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">left</span><span class="p">:</span>
        <span class="n">lstrip_flags</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>
        <span class="n">flag_lists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lstrip_flags</span><span class="p">)</span>
    <span class="n">strip_flags</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">and_lists</span><span class="p">(</span><span class="o">*</span><span class="n">flag_lists</span><span class="p">)</span>
    <span class="n">stripped_list</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">strip_flags</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stripped_list</span></div>


<div class="viewcode-block" id="insert_values"><a class="viewcode-back" href="../../utool.html#utool.util_list.insert_values">[docs]</a><span class="k">def</span> <span class="nf">insert_values</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="k">assert</span> <span class="kc">False</span>
        <span class="k">del</span> <span class="n">list_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">list_</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">left_part</span> <span class="o">=</span> <span class="n">list_</span><span class="p">[:</span><span class="n">index</span><span class="p">]</span>
        <span class="n">right_part</span> <span class="o">=</span> <span class="n">list_</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>
        <span class="n">new_list</span> <span class="o">=</span> <span class="n">left_part</span> <span class="o">+</span> <span class="n">values</span> <span class="o">+</span> <span class="n">right_part</span>
    <span class="k">return</span> <span class="n">new_list</span></div>


<div class="viewcode-block" id="aslist"><a class="viewcode-back" href="../../utool.html#utool.util_list.aslist">[docs]</a><span class="k">def</span> <span class="nf">aslist</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ensures that the sequence object is a Python list.</span>
<span class="sd">    Handles, numpy arrays, and python sequences (e.g. tuples, and iterables).</span>

<span class="sd">    Args:</span>
<span class="sd">        sequence (sequence): a list-like object</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: list_ - `sequence` as a Python list</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_list import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; s1 = [1, 2, 3]</span>
<span class="sd">        &gt;&gt;&gt; s2 = (1, 2, 3)</span>
<span class="sd">        &gt;&gt;&gt; assert aslist(s1) is s1</span>
<span class="sd">        &gt;&gt;&gt; assert aslist(s2) is not s2</span>
<span class="sd">        &gt;&gt;&gt; aslist(np.array([[1, 2], [3, 4], [5, 6]]))</span>
<span class="sd">        [[1, 2], [3, 4], [5, 6]]</span>
<span class="sd">        &gt;&gt;&gt; aslist(range(3))</span>
<span class="sd">        [0, 1, 2]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">sequence</span>
    <span class="k">elif</span> <span class="n">util_type</span><span class="o">.</span><span class="n">HAVE_NUMPY</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sequence</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">list_</span> <span class="o">=</span> <span class="n">sequence</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">list_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">sequence</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">list_</span></div>


<span class="c1"># def partition2(list_, idxs1, idxs2):</span>
<span class="c1">#    list1_ = ut.take(list_, idxs1)</span>
<span class="c1">#    list2_ = list(zip(ut.take(list_, idxs2)))</span>
<span class="c1">#    partitioned_items = [list1_, list2_]</span>
<span class="c1">#    return partitioned_items</span>


<span class="c1"># class ListLike(object):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    similar to DictLike</span>
<span class="c1">#    &quot;&quot;&quot;</span>

<span class="c1">#    def getitem(self, index):</span>
<span class="c1">#        raise NotImplementedError(&#39;abstract getitem function&#39;)</span>

<span class="c1">#    def setitem(self, index, value):</span>
<span class="c1">#        raise NotImplementedError(&#39;abstract setitem function&#39;)</span>

<span class="c1">#    def append(self, value):</span>
<span class="c1">#        raise NotImplementedError(&#39;Unfinished&#39;)</span>

<span class="c1">#    def insert(self, index, value):</span>
<span class="c1">#        raise NotImplementedError(&#39;Unfinished&#39;)</span>

<span class="c1">#    def extend(self, values):</span>
<span class="c1">#        raise NotImplementedError(&#39;Unfinished&#39;)</span>

<span class="c1">#    def pop(self, value):</span>
<span class="c1">#        raise NotImplementedError(&#39;Unfinished&#39;)</span>

<span class="c1">#    def remove(self, value):</span>
<span class="c1">#        raise NotImplementedError(&#39;Unfinished&#39;)</span>

<span class="c1">#    def reverse(self, value):</span>
<span class="c1">#        raise NotImplementedError(&#39;Unfinished&#39;)</span>

<span class="c1">#    def sort(self, value):</span>
<span class="c1">#        raise NotImplementedError(&#39;Unfinished&#39;)</span>

<span class="c1">#    def aslist(self):</span>
<span class="c1">#        return [self[idx] for idx in range(len(self))]</span>

<span class="c1">#    def __repr__(self):</span>
<span class="c1">#        return repr(self.aslist())</span>

<span class="c1">#    def __str__(self):</span>
<span class="c1">#        return str(self.aslist())</span>

<span class="c1">#    def __len__(self):</span>
<span class="c1">#        return len(list(self.keys()))</span>

<span class="c1">#    def __contains__(self, key):</span>
<span class="c1">#        return key in self.aslist()</span>

<span class="c1">#    def __getitem__(self, key):</span>
<span class="c1">#        return self.getitem(key)</span>

<span class="c1">#    def __setitem__(self, key, value):</span>
<span class="c1">#        return self.setitem(key, value)</span>


<div class="viewcode-block" id="length_hint"><a class="viewcode-back" href="../../utool.html#utool.util_list.length_hint">[docs]</a><span class="k">def</span> <span class="nf">length_hint</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an estimate of the number of items in obj.</span>

<span class="sd">    This is the PEP 424 implementation.</span>
<span class="sd">    If the object supports len(), the result will be</span>
<span class="sd">    exact. Otherwise, it may over- or under-estimate by an</span>
<span class="sd">    arbitrary amount. The result will be an integer &gt;= 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">get_hint</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="fm">__length_hint__</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hint</span> <span class="o">=</span> <span class="n">get_hint</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>
        <span class="k">if</span> <span class="n">hint</span> <span class="ow">is</span> <span class="bp">NotImplemented</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">default</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hint</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Length hint must be an integer, not </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">hint</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">hint</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;__length_hint__() should return &gt;= 0&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hint</span></div>


<div class="viewcode-block" id="partial_order"><a class="viewcode-back" href="../../utool.html#utool.util_list.partial_order">[docs]</a><span class="k">def</span> <span class="nf">partial_order</span><span class="p">(</span><span class="n">list_</span><span class="p">,</span> <span class="n">part</span><span class="p">):</span>
    <span class="n">list_items</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">list_</span><span class="p">)</span>
    <span class="n">part_items</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
    <span class="n">begin</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">part</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">list_items</span><span class="p">]</span>
    <span class="n">end</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">list_</span> <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">part_items</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">begin</span> <span class="o">+</span> <span class="n">end</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CommandLine:</span>
<span class="sd">        python -c &quot;import utool, utool.util_list; utool.doctest_funcs(utool.util_list, allexamples=True)&quot;</span>
<span class="sd">        python -c &quot;import utool, utool.util_list; utool.doctest_funcs(utool.util_list)&quot;</span>
<span class="sd">        python -m utool.util_list</span>
<span class="sd">        python -m utool.util_list --allexamples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span>

    <span class="n">multiprocessing</span><span class="o">.</span><span class="n">freeze_support</span><span class="p">()</span>  <span class="c1"># for win32</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>  <span class="c1"># NOQA</span>

    <span class="n">ut</span><span class="o">.</span><span class="n">doctest_funcs</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">wbia-vtool</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../utool.html">utool package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../utool.html">utool</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Wild Me.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>