
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>utool.util_graph &#8212; wbia-vtool 3.0.1 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for utool.util_graph</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="k">pass</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">from</span> <span class="nn">utool</span> <span class="k">import</span> <span class="n">util_inject</span>
<span class="kn">from</span> <span class="nn">utool</span> <span class="k">import</span> <span class="n">util_const</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="n">reduce</span><span class="p">,</span> <span class="nb">zip</span><span class="p">,</span> <span class="nb">range</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>

<span class="p">(</span><span class="nb">print</span><span class="p">,</span> <span class="n">rrr</span><span class="p">,</span> <span class="n">profile</span><span class="p">)</span> <span class="o">=</span> <span class="n">util_inject</span><span class="o">.</span><span class="n">inject2</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="nx_topsort_nodes"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_topsort_nodes">[docs]</a><span class="k">def</span> <span class="nf">nx_topsort_nodes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">node_rank</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">nx_topsort_rank</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
    <span class="n">node_idx</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">rebase_labels</span><span class="p">(</span><span class="n">node_rank</span><span class="p">)</span>
    <span class="n">sorted_nodes</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">node_idx</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sorted_nodes</span></div>


<div class="viewcode-block" id="nx_topsort_rank"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_topsort_rank">[docs]</a><span class="k">def</span> <span class="nf">nx_topsort_rank</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    graph = inputs.exi_graph.reverse()</span>
<span class="sd">    nodes = flat_node_order_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
        <span class="c1"># Determenistic version</span>
        <span class="c1"># Ok, this doesn&#39;t work.</span>
        <span class="n">dag_ranks</span> <span class="o">=</span> <span class="n">nx_dag_node_rank</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
        <span class="n">toprank</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">dag_ranks</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Non-determenistic version</span>
        <span class="n">dag_ranks</span> <span class="o">=</span> <span class="n">nx_dag_node_rank</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
        <span class="n">topsort</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">topological_sort</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span>
        <span class="c1"># print(&#39;topsort = %r&#39; % (topsort,))</span>
        <span class="n">node_to_top_rank</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">make_index_lookup</span><span class="p">(</span><span class="n">topsort</span><span class="p">)</span>
        <span class="n">toprank</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_take</span><span class="p">(</span><span class="n">node_to_top_rank</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">toprank</span></div>


<div class="viewcode-block" id="nx_common_descendants"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_common_descendants">[docs]</a><span class="k">def</span> <span class="nf">nx_common_descendants</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">):</span>
    <span class="n">descendants1</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">descendants</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node1</span><span class="p">)</span>
    <span class="n">descendants2</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">descendants</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node2</span><span class="p">)</span>
    <span class="n">common_descendants</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">descendants1</span><span class="p">,</span> <span class="n">descendants2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">common_descendants</span></div>


<div class="viewcode-block" id="nx_common_ancestors"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_common_ancestors">[docs]</a><span class="k">def</span> <span class="nf">nx_common_ancestors</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">):</span>
    <span class="n">ancestors1</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node1</span><span class="p">)</span>
    <span class="n">ancestors2</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">ancestors</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">node2</span><span class="p">)</span>
    <span class="n">common_ancestors</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">ancestors1</span><span class="p">,</span> <span class="n">ancestors2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">common_ancestors</span></div>


<div class="viewcode-block" id="nx_make_adj_matrix"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_make_adj_matrix">[docs]</a><span class="k">def</span> <span class="nf">nx_make_adj_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="n">node2_idx</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">make_index_lookup</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
    <span class="n">edge2_idx</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">dict_take</span><span class="p">,</span> <span class="n">node2_idx</span><span class="p">)</span>
    <span class="n">uv_list</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">lmap</span><span class="p">(</span><span class="n">edge2_idx</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)))</span>
    <span class="n">A</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">uv_list</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="nx_transitive_reduction"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_transitive_reduction">[docs]</a><span class="k">def</span> <span class="nf">nx_transitive_reduction</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        https://en.wikipedia.org/wiki/Transitive_reduction#Computing_the_reduction_using_the_closure</span>
<span class="sd">        http://dept-info.labri.fr/~thibault/tmp/0201008.pdf</span>
<span class="sd">        http://stackoverflow.com/questions/17078696/transitive-reduction-of-directed-graph-in-python</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_graph nx_transitive_reduction --show</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; G = nx.DiGraph([(&#39;a&#39;, &#39;b&#39;), (&#39;a&#39;, &#39;c&#39;), (&#39;a&#39;, &#39;e&#39;),</span>
<span class="sd">        &gt;&gt;&gt;                 (&#39;a&#39;, &#39;d&#39;), (&#39;b&#39;, &#39;d&#39;), (&#39;c&#39;, &#39;e&#39;),</span>
<span class="sd">        &gt;&gt;&gt;                 (&#39;d&#39;, &#39;e&#39;), (&#39;c&#39;, &#39;e&#39;), (&#39;c&#39;, &#39;d&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; G = testdata_graph()[1]</span>
<span class="sd">        &gt;&gt;&gt; G_tr = nx_transitive_reduction(G, mode=1)</span>
<span class="sd">        &gt;&gt;&gt; G_tr2 = nx_transitive_reduction(G, mode=1)</span>
<span class="sd">        &gt;&gt;&gt; ut.quit_if_noshow()</span>
<span class="sd">        &gt;&gt;&gt; try:</span>
<span class="sd">        &gt;&gt;&gt;     import wbia.plottool as pt</span>
<span class="sd">        &gt;&gt;&gt; except ImportError:</span>
<span class="sd">        &gt;&gt;&gt;     import wbia.plottool as pt</span>
<span class="sd">        &gt;&gt;&gt; G_ = nx.dag.transitive_closure(G)</span>
<span class="sd">        &gt;&gt;&gt; pt.show_nx(G    , pnum=(1, 5, 1), fnum=1)</span>
<span class="sd">        &gt;&gt;&gt; pt.show_nx(G_tr , pnum=(1, 5, 2), fnum=1)</span>
<span class="sd">        &gt;&gt;&gt; pt.show_nx(G_tr2 , pnum=(1, 5, 3), fnum=1)</span>
<span class="sd">        &gt;&gt;&gt; pt.show_nx(G_   , pnum=(1, 5, 4), fnum=1)</span>
<span class="sd">        &gt;&gt;&gt; pt.show_nx(nx.dag.transitive_closure(G_tr), pnum=(1, 5, 5), fnum=1)</span>
<span class="sd">        &gt;&gt;&gt; ut.show_if_requested()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">has_cycles</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">nx</span><span class="o">.</span><span class="n">is_directed_acyclic_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">has_cycles</span><span class="p">:</span>
        <span class="c1"># FIXME: this does not work for cycle graphs.</span>
        <span class="c1"># Need to do algorithm on SCCs</span>
        <span class="n">G_orig</span> <span class="o">=</span> <span class="n">G</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">condensation</span><span class="p">(</span><span class="n">G_orig</span><span class="p">)</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="n">node2_idx</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">make_index_lookup</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>

    <span class="c1"># For each node u, perform DFS consider its set of (non-self) children C.</span>
    <span class="c1"># For each descendant v, of a node in C, remove any edge from u to v.</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">G_tr</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">G_tr</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="c1"># Remove self loops</span>
            <span class="k">if</span> <span class="n">G_tr</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
                <span class="n">G_tr</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span>
            <span class="c1"># For each child of the parent</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">G_tr</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">parent</span><span class="p">)):</span>
                <span class="c1"># Preorder nodes includes its argument (no added complexity)</span>
                <span class="k">for</span> <span class="n">gchild</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">G_tr</span><span class="o">.</span><span class="n">successors</span><span class="p">(</span><span class="n">child</span><span class="p">)):</span>
                    <span class="c1"># Remove all edges from parent to non-child descendants</span>
                    <span class="k">for</span> <span class="n">descendant</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">dfs_preorder_nodes</span><span class="p">(</span><span class="n">G_tr</span><span class="p">,</span> <span class="n">gchild</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">G_tr</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">descendant</span><span class="p">):</span>
                            <span class="n">G_tr</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">descendant</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">has_cycles</span><span class="p">:</span>
            <span class="c1"># Uncondense graph</span>
            <span class="n">uncondensed_G_tr</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;mapping&#39;</span><span class="p">]</span>
            <span class="n">uncondensed_G_tr</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">inv_mapping</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">invert_dict</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">unique_vals</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G_tr</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                <span class="n">u_</span> <span class="o">=</span> <span class="n">inv_mapping</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">v_</span> <span class="o">=</span> <span class="n">inv_mapping</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">uncondensed_G_tr</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u_</span><span class="p">,</span> <span class="n">v_</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">inv_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">directed_cycle</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">itertwo</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                    <span class="n">uncondensed_G_tr</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">directed_cycle</span><span class="p">)</span>
            <span class="n">G_tr</span> <span class="o">=</span> <span class="n">uncondensed_G_tr</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">make_adj_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
            <span class="n">edge2_idx</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">dict_take</span><span class="p">,</span> <span class="n">node2_idx</span><span class="p">)</span>
            <span class="n">uv_list</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">lmap</span><span class="p">(</span><span class="n">edge2_idx</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">)))</span>
            <span class="n">A</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">uv_list</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">A</span>

        <span class="n">G_</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dag</span><span class="o">.</span><span class="n">transitive_closure</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

        <span class="n">A</span> <span class="o">=</span> <span class="n">make_adj_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">make_adj_matrix</span><span class="p">(</span><span class="n">G_</span><span class="p">)</span>

        <span class="c1"># AB = A * B</span>
        <span class="c1"># AB = A.T.dot(B)</span>
        <span class="n">AB</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
        <span class="c1"># AB = A.dot(B.T)</span>

        <span class="n">A_and_notAB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">AB</span><span class="p">))</span>
        <span class="n">tr_uvs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">A_and_notAB</span><span class="p">)</span>

        <span class="c1"># nodes = G.nodes()</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">ut</span><span class="o">.</span><span class="n">unflat_take</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">tr_uvs</span><span class="p">)))</span>

        <span class="n">G_tr</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
        <span class="n">G_tr</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
        <span class="n">G_tr</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">has_cycles</span><span class="p">:</span>
            <span class="c1"># Uncondense graph</span>
            <span class="n">uncondensed_G_tr</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="vm">__class__</span><span class="p">()</span>
            <span class="n">mapping</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="s1">&#39;mapping&#39;</span><span class="p">]</span>
            <span class="n">uncondensed_G_tr</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">inv_mapping</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">invert_dict</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">unique_vals</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G_tr</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
                <span class="n">u_</span> <span class="o">=</span> <span class="n">inv_mapping</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">v_</span> <span class="o">=</span> <span class="n">inv_mapping</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">uncondensed_G_tr</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u_</span><span class="p">,</span> <span class="n">v_</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">inv_mapping</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">directed_cycle</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">itertwo</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">wrap</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
                    <span class="n">uncondensed_G_tr</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">directed_cycle</span><span class="p">)</span>
            <span class="n">G_tr</span> <span class="o">=</span> <span class="n">uncondensed_G_tr</span>
    <span class="k">return</span> <span class="n">G_tr</span></div>


<div class="viewcode-block" id="nx_source_nodes"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_source_nodes">[docs]</a><span class="k">def</span> <span class="nf">nx_source_nodes</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="c1"># for node in nx.dag.topological_sort(graph):</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">in_degree</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">node</span></div>


<div class="viewcode-block" id="nx_sink_nodes"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_sink_nodes">[docs]</a><span class="k">def</span> <span class="nf">nx_sink_nodes</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="c1"># for node in nx.dag.topological_sort(graph):</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">out_degree</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">node</span></div>


<span class="c1"># def nx_sink_nodes(graph):</span>
<span class="c1">#     topsort_iter = nx.dag.topological_sort(graph)</span>
<span class="c1">#     sink_iter = (node for node in topsort_iter</span>
<span class="c1">#                  if graph.out_degree(node) == 0)</span>
<span class="c1">#     return sink_iter</span>


<div class="viewcode-block" id="nx_to_adj_dict"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_to_adj_dict">[docs]</a><span class="k">def</span> <span class="nf">nx_to_adj_dict</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">adj_dict</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">ddict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">edges</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">adjacency</span><span class="p">():</span>
        <span class="n">adj_dict</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
    <span class="n">adj_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">adj_dict</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">adj_dict</span></div>


<div class="viewcode-block" id="nx_from_adj_dict"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_from_adj_dict">[docs]</a><span class="k">def</span> <span class="nf">nx_from_adj_dict</span><span class="p">(</span><span class="n">adj_dict</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">adj_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">adj</span> <span class="ow">in</span> <span class="n">adj_dict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">adj</span><span class="p">]</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graph</span></div>


<div class="viewcode-block" id="nx_dag_node_rank"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_dag_node_rank">[docs]</a><span class="k">def</span> <span class="nf">nx_dag_node_rank</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns rank of nodes that define the &quot;level&quot; each node is on in a</span>
<span class="sd">    topological sort. This is the same as the Graphviz dot rank.</span>

<span class="sd">    Ignore:</span>
<span class="sd">        simple_graph = ut.simplify_graph(exi_graph)</span>
<span class="sd">        adj_dict = ut.nx_to_adj_dict(simple_graph)</span>
<span class="sd">        import wbia.plottool as pt</span>
<span class="sd">        pt.qt4ensure()</span>
<span class="sd">        pt.show_nx(graph)</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; adj_dict = {0: [5], 1: [5], 2: [1], 3: [4], 4: [0], 5: [], 6: [4], 7: [9], 8: [6], 9: [1]}</span>
<span class="sd">        &gt;&gt;&gt; nodes = [2, 1, 5]</span>
<span class="sd">        &gt;&gt;&gt; f_graph = ut.nx_from_adj_dict(adj_dict, nx.DiGraph)</span>
<span class="sd">        &gt;&gt;&gt; graph = f_graph.reverse()</span>
<span class="sd">        &gt;&gt;&gt; #ranks = ut.nx_dag_node_rank(graph, nodes)</span>
<span class="sd">        &gt;&gt;&gt; ranks = ut.nx_dag_node_rank(graph, nodes)</span>
<span class="sd">        &gt;&gt;&gt; result = (&#39;ranks = %r&#39; % (ranks,))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        ranks = [3, 2, 1]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">source</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">nx_source_nodes</span><span class="p">(</span><span class="n">graph</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">longest_paths</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="p">[(</span><span class="n">target</span><span class="p">,</span> <span class="n">dag_longest_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span> <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>
    <span class="p">)</span>
    <span class="n">node_to_rank</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">map_dict_vals</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">longest_paths</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node_to_rank</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ranks</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_take</span><span class="p">(</span><span class="n">node_to_rank</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ranks</span></div>


<div class="viewcode-block" id="nx_all_nodes_between"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_all_nodes_between">[docs]</a><span class="k">def</span> <span class="nf">nx_all_nodes_between</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find all nodes with on paths between source and target.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="k">if</span> <span class="n">source</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># assume there is a single source</span>
        <span class="n">sources</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">nx_source_nodes</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;specify source if there is not only one&#39;</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># assume there is a single source</span>
        <span class="n">sinks</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">nx_sink_nodes</span><span class="p">(</span><span class="n">graph</span><span class="p">))</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sinks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;specify sink if there is not only one&#39;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">sinks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">all_simple_paths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">all_simple_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">set</span><span class="p">,</span> <span class="n">all_simple_paths</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">nodes</span></div>


<div class="viewcode-block" id="nx_all_simple_edge_paths"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_all_simple_edge_paths">[docs]</a><span class="k">def</span> <span class="nf">nx_all_simple_edge_paths</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns each path from source to target as a list of edges.</span>

<span class="sd">    This function is meant to be used with MultiGraphs or MultiDiGraphs.</span>
<span class="sd">    When ``keys`` is True each edge in the path is returned with its unique key</span>
<span class="sd">    identifier. In this case it is possible to distinguish between different</span>
<span class="sd">    paths along different edges between the same two nodes.</span>

<span class="sd">    Derived from simple_paths.py in networkx</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cutoff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">cutoff</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>
    <span class="kn">import</span> <span class="nn">six</span>

    <span class="n">visited_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
    <span class="n">visited_edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">():</span>
        <span class="n">get_neighbs</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">keys</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">get_neighbs</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="n">edge_stack</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">get_neighbs</span><span class="p">(</span><span class="n">source</span><span class="p">))]</span>
    <span class="k">while</span> <span class="n">edge_stack</span><span class="p">:</span>
        <span class="n">children_edges</span> <span class="o">=</span> <span class="n">edge_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">child_edge</span> <span class="o">=</span> <span class="n">six</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="n">children_edges</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">child_edge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">visited_nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">visited_edges</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited_nodes</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span>
            <span class="n">child_node</span> <span class="o">=</span> <span class="n">child_edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">child_node</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">visited_edges</span> <span class="o">+</span> <span class="p">[</span><span class="n">child_edge</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">child_node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_nodes</span><span class="p">:</span>
                <span class="n">visited_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child_node</span><span class="p">)</span>
                <span class="n">visited_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child_edge</span><span class="p">)</span>
                <span class="n">edge_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">get_neighbs</span><span class="p">(</span><span class="n">child_node</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="p">[</span><span class="n">child_edge</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">children_edges</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">visited_edges</span> <span class="o">+</span> <span class="p">[</span><span class="n">edge</span><span class="p">]</span>
            <span class="n">edge_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">visited_nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">visited_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">visited_edges</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span></div>


<div class="viewcode-block" id="nx_edges_between"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_edges_between">[docs]</a><span class="k">def</span> <span class="nf">nx_edges_between</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span> <span class="n">nodes1</span><span class="p">,</span> <span class="n">nodes2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">assume_disjoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">assume_sparse</span><span class="o">=</span><span class="kc">True</span>
<span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get edges between two components or within a single component</span>

<span class="sd">    Args:</span>
<span class="sd">        graph (nx.Graph): the graph</span>
<span class="sd">        nodes1 (set): list of nodes</span>
<span class="sd">        nodes2 (set): (default=None) if None it is equivlanet to nodes2=nodes1</span>
<span class="sd">        assume_disjoint (bool): skips expensive check to ensure edges arnt</span>
<span class="sd">            returned twice (default=False)</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_graph --test-nx_edges_between</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; edges = [</span>
<span class="sd">        &gt;&gt;&gt;     (1, 2), (2, 3), (3, 4), (4, 1), (4, 3),  # cc 1234</span>
<span class="sd">        &gt;&gt;&gt;     (1, 5), (7, 2), (5, 1),  # cc 567 / 5678</span>
<span class="sd">        &gt;&gt;&gt;     (7, 5), (5, 6), (8, 7),</span>
<span class="sd">        &gt;&gt;&gt; ]</span>
<span class="sd">        &gt;&gt;&gt; digraph = nx.DiGraph(edges)</span>
<span class="sd">        &gt;&gt;&gt; graph = nx.Graph(edges)</span>
<span class="sd">        &gt;&gt;&gt; nodes1 = [1, 2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; nodes2 = [5, 6, 7]</span>
<span class="sd">        &gt;&gt;&gt; n2 = sorted(nx_edges_between(graph, nodes1, nodes2))</span>
<span class="sd">        &gt;&gt;&gt; n4 = sorted(nx_edges_between(graph, nodes1))</span>
<span class="sd">        &gt;&gt;&gt; n5 = sorted(nx_edges_between(graph, nodes1, nodes1))</span>
<span class="sd">        &gt;&gt;&gt; n1 = sorted(nx_edges_between(digraph, nodes1, nodes2))</span>
<span class="sd">        &gt;&gt;&gt; n3 = sorted(nx_edges_between(digraph, nodes1))</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;n2 == %r&#39; % (n2,))</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;n4 == %r&#39; % (n4,))</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;n5 == %r&#39; % (n5,))</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;n1 == %r&#39; % (n1,))</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;n3 == %r&#39; % (n3,))</span>
<span class="sd">        &gt;&gt;&gt; assert n2 == ([(1, 5), (2, 7)]), &#39;2&#39;</span>
<span class="sd">        &gt;&gt;&gt; assert n4 == ([(1, 2), (1, 4), (2, 3), (3, 4)]), &#39;4&#39;</span>
<span class="sd">        &gt;&gt;&gt; assert n5 == ([(1, 2), (1, 4), (2, 3), (3, 4)]), &#39;5&#39;</span>
<span class="sd">        &gt;&gt;&gt; assert n1 == ([(1, 5), (5, 1), (7, 2)]), &#39;1&#39;</span>
<span class="sd">        &gt;&gt;&gt; assert n3 == ([(1, 2), (2, 3), (3, 4), (4, 1), (4, 3)]), &#39;3&#39;</span>
<span class="sd">        &gt;&gt;&gt; n6 = sorted(nx_edges_between(digraph, nodes1 + [6], nodes2 + [1, 2], assume_sparse=True))</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;n6 = %r&#39; % (n6,))</span>
<span class="sd">        &gt;&gt;&gt; n6 = sorted(nx_edges_between(digraph, nodes1 + [6], nodes2 + [1, 2], assume_sparse=False))</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;n6 = %r&#39; % (n6,))</span>
<span class="sd">        &gt;&gt;&gt; assert n6 == ([(1, 2), (1, 5), (2, 3), (4, 1), (5, 1), (5, 6), (7, 2)]), &#39;6&#39;</span>

<span class="sd">    Timeit:</span>
<span class="sd">        from utool.util_graph import *  # NOQA</span>
<span class="sd">        # ut.timeit_compare()</span>
<span class="sd">        import networkx as nx</span>
<span class="sd">        import utool as ut</span>
<span class="sd">        graph = nx.fast_gnp_random_graph(1000, .001)</span>
<span class="sd">        list(nx.connected_components(graph))</span>
<span class="sd">        rng = np.random.RandomState(0)</span>
<span class="sd">        nodes1 = set(rng.choice(list(graph.nodes()), 500, replace=False))</span>
<span class="sd">        nodes2 = set(graph.nodes()) - nodes1</span>
<span class="sd">        edges_between = ut.nx_edges_between</span>
<span class="sd">        %timeit list(edges_between(graph, nodes1, nodes2, assume_sparse=False, assume_disjoint=True))</span>
<span class="sd">        %timeit list(edges_between(graph, nodes1, nodes2, assume_sparse=False, assume_disjoint=False))</span>
<span class="sd">        %timeit list(edges_between(graph, nodes1, nodes2, assume_sparse=True, assume_disjoint=False))</span>
<span class="sd">        %timeit list(edges_between(graph, nodes1, nodes2, assume_sparse=True, assume_disjoint=True))</span>

<span class="sd">        graph = nx.fast_gnp_random_graph(1000, .1)</span>
<span class="sd">        rng = np.random.RandomState(0)</span>
<span class="sd">        print(graph.number_of_edges())</span>
<span class="sd">        nodes1 = set(rng.choice(list(graph.nodes()), 500, replace=False))</span>
<span class="sd">        nodes2 = set(graph.nodes()) - nodes1</span>
<span class="sd">        edges_between = ut.nx_edges_between</span>
<span class="sd">        %timeit list(edges_between(graph, nodes1, nodes2, assume_sparse=True, assume_disjoint=True))</span>
<span class="sd">        %timeit list(edges_between(graph, nodes1, nodes2, assume_sparse=False, assume_disjoint=True))</span>

<span class="sd">    Ignore:</span>
<span class="sd">        graph = nx.DiGraph(edges)</span>
<span class="sd">        graph = nx.Graph(edges)</span>
<span class="sd">        nodes1 = [1, 2, 3, 4]</span>
<span class="sd">        nodes2 = nodes1</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">assume_sparse</span><span class="p">:</span>
        <span class="c1"># Method 1 is where we check the intersection of existing edges</span>
        <span class="c1"># and the edges in the second set (faster for sparse graphs)</span>

        <span class="c1"># helpers nx_edges between</span>
        <span class="k">def</span> <span class="nf">_node_combo_lower</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">both</span><span class="p">):</span>
            <span class="n">both_lower</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">both</span><span class="p">:</span>
                <span class="n">neighbs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>
                <span class="n">neighbsBB_lower</span> <span class="o">=</span> <span class="n">neighbs</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">both_lower</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">neighbsBB_lower</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="n">both_lower</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_node_combo_upper</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">both</span><span class="p">):</span>
            <span class="n">both_upper</span> <span class="o">=</span> <span class="n">both</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">both</span><span class="p">:</span>
                <span class="n">neighbs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>
                <span class="n">neighbsBB_upper</span> <span class="o">=</span> <span class="n">neighbs</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">both_upper</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">neighbsBB_upper</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="n">both_upper</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_node_product</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">only1</span><span class="p">,</span> <span class="n">only2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">only1</span><span class="p">:</span>
                <span class="n">neighbs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span>
                <span class="n">neighbs12</span> <span class="o">=</span> <span class="n">neighbs</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">only2</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">neighbs12</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="c1"># Test for special cases</span>
        <span class="k">if</span> <span class="n">nodes2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nodes2</span> <span class="ow">is</span> <span class="n">nodes1</span><span class="p">:</span>
            <span class="c1"># Case where we just are finding internal edges</span>
            <span class="n">both</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
                <span class="n">edge_sets</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_node_combo_upper</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">both</span><span class="p">),</span>  <span class="c1"># B-to-B (upper)</span>
                    <span class="n">_node_combo_lower</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">both</span><span class="p">),</span>  <span class="c1"># B-to-B (lower)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edge_sets</span> <span class="o">=</span> <span class="p">(</span><span class="n">_node_combo_upper</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">both</span><span class="p">),)</span>  <span class="c1"># B-to-B (upper)</span>
        <span class="k">elif</span> <span class="n">assume_disjoint</span><span class="p">:</span>
            <span class="c1"># Case where we find edges between disjoint sets</span>
            <span class="n">only1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes1</span><span class="p">)</span>
            <span class="n">only2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
                <span class="n">edge_sets</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_node_product</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">only1</span><span class="p">,</span> <span class="n">only2</span><span class="p">),</span>  <span class="c1"># 1-to-2</span>
                    <span class="n">_node_product</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">only2</span><span class="p">,</span> <span class="n">only1</span><span class="p">),</span>  <span class="c1"># 2-to-1</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edge_sets</span> <span class="o">=</span> <span class="p">(</span><span class="n">_node_product</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">only1</span><span class="p">,</span> <span class="n">only2</span><span class="p">),)</span>  <span class="c1"># 1-to-2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Full general case</span>
            <span class="n">nodes1_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nodes2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nodes2_</span> <span class="o">=</span> <span class="n">nodes1_</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nodes2_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes2</span><span class="p">)</span>
            <span class="n">both</span> <span class="o">=</span> <span class="n">nodes1_</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">nodes2_</span><span class="p">)</span>
            <span class="n">only1</span> <span class="o">=</span> <span class="n">nodes1_</span> <span class="o">-</span> <span class="n">both</span>
            <span class="n">only2</span> <span class="o">=</span> <span class="n">nodes2_</span> <span class="o">-</span> <span class="n">both</span>

            <span class="c1"># This could be made faster by avoiding duplicate</span>
            <span class="c1"># calls to set(graph.adj[u]) in the helper functions</span>
            <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
                <span class="n">edge_sets</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_node_product</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">only1</span><span class="p">,</span> <span class="n">only2</span><span class="p">),</span>  <span class="c1"># 1-to-2</span>
                    <span class="n">_node_product</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">only1</span><span class="p">,</span> <span class="n">both</span><span class="p">),</span>  <span class="c1"># 1-to-B</span>
                    <span class="n">_node_combo_upper</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">both</span><span class="p">),</span>  <span class="c1"># B-to-B (u)</span>
                    <span class="n">_node_combo_lower</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">both</span><span class="p">),</span>  <span class="c1"># B-to-B (l)</span>
                    <span class="n">_node_product</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">both</span><span class="p">,</span> <span class="n">only1</span><span class="p">),</span>  <span class="c1"># B-to-1</span>
                    <span class="n">_node_product</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">both</span><span class="p">,</span> <span class="n">only2</span><span class="p">),</span>  <span class="c1"># B-to-2</span>
                    <span class="n">_node_product</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">only2</span><span class="p">,</span> <span class="n">both</span><span class="p">),</span>  <span class="c1"># 2-to-B</span>
                    <span class="n">_node_product</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">only2</span><span class="p">,</span> <span class="n">only1</span><span class="p">),</span>  <span class="c1"># 2-to-1</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">edge_sets</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">_node_product</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">only1</span><span class="p">,</span> <span class="n">only2</span><span class="p">),</span>  <span class="c1"># 1-to-2</span>
                    <span class="n">_node_product</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">only1</span><span class="p">,</span> <span class="n">both</span><span class="p">),</span>  <span class="c1"># 1-to-B</span>
                    <span class="n">_node_combo_upper</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">both</span><span class="p">),</span>  <span class="c1"># B-to-B (u)</span>
                    <span class="n">_node_product</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">only2</span><span class="p">,</span> <span class="n">both</span><span class="p">),</span>  <span class="c1"># 2-to-B</span>
                <span class="p">)</span>

        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">edge_sets</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Method 2 is where we enumerate all possible edges and just take the</span>
        <span class="c1"># ones that exist (faster for very dense graphs)</span>
        <span class="k">if</span> <span class="n">nodes2</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nodes2</span> <span class="ow">is</span> <span class="n">nodes1</span><span class="p">:</span>
            <span class="n">edge_iter</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">nodes1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">assume_disjoint</span><span class="p">:</span>
                <span class="c1"># We assume len(isect(nodes1, nodes2)) == 0</span>
                <span class="n">edge_iter</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">nodes1</span><span class="p">,</span> <span class="n">nodes2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># make sure a single edge is not returned twice</span>
                <span class="c1"># in the case where len(isect(nodes1, nodes2)) &gt; 0</span>
                <span class="n">nodes1_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes1</span><span class="p">)</span>
                <span class="n">nodes2_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nodes2</span><span class="p">)</span>
                <span class="n">nodes_isect</span> <span class="o">=</span> <span class="n">nodes1_</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">nodes2_</span><span class="p">)</span>
                <span class="n">nodes_only1</span> <span class="o">=</span> <span class="n">nodes1_</span> <span class="o">-</span> <span class="n">nodes_isect</span>
                <span class="n">nodes_only2</span> <span class="o">=</span> <span class="n">nodes2_</span> <span class="o">-</span> <span class="n">nodes_isect</span>
                <span class="n">edge_sets</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">nodes_only1</span><span class="p">,</span> <span class="n">nodes_only2</span><span class="p">),</span>
                    <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">nodes_only1</span><span class="p">,</span> <span class="n">nodes_isect</span><span class="p">),</span>
                    <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">nodes_only2</span><span class="p">,</span> <span class="n">nodes_isect</span><span class="p">),</span>
                    <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">nodes_isect</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                <span class="p">]</span>
                <span class="n">edge_iter</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">(</span><span class="n">edge_sets</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">edge_iter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span>
                <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span> <span class="n">n1</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">edge_iter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span></div>


<div class="viewcode-block" id="nx_delete_node_attr"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_delete_node_attr">[docs]</a><span class="k">def</span> <span class="nf">nx_delete_node_attr</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes node attributes</span>

<span class="sd">    Doctest:</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; G = nx.karate_club_graph()</span>
<span class="sd">        &gt;&gt;&gt; nx.set_node_attributes(G, name=&#39;foo&#39;, values=&#39;bar&#39;)</span>
<span class="sd">        &gt;&gt;&gt; datas = nx.get_node_attributes(G, &#39;club&#39;)</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_node_attributes(G, &#39;club&#39;)) == 34</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_node_attributes(G, &#39;foo&#39;)) == 34</span>
<span class="sd">        &gt;&gt;&gt; ut.nx_delete_node_attr(G, [&#39;club&#39;, &#39;foo&#39;], nodes=[1, 2])</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_node_attributes(G, &#39;club&#39;)) == 32</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_node_attributes(G, &#39;foo&#39;)) == 32</span>
<span class="sd">        &gt;&gt;&gt; ut.nx_delete_node_attr(G, [&#39;club&#39;])</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_node_attributes(G, &#39;club&#39;)) == 0</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_node_attributes(G, &#39;foo&#39;)) == 32</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="n">removed</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># names = [name] if not isinstance(name, list) else name</span>
    <span class="n">node_dict</span> <span class="o">=</span> <span class="n">nx_node_dict</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name_</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">node_dict</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">name_</span><span class="p">]</span>
                    <span class="n">removed</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">node_dict</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">name</span><span class="p">]</span>
                <span class="n">removed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
    <span class="k">return</span> <span class="n">removed</span></div>


<div class="viewcode-block" id="nx_delete_edge_attr"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_delete_edge_attr">[docs]</a><span class="nd">@profile</span>
<span class="k">def</span> <span class="nf">nx_delete_edge_attr</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Removes an attributes from specific edges in the graph</span>

<span class="sd">    Doctest:</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; G = nx.karate_club_graph()</span>
<span class="sd">        &gt;&gt;&gt; nx.set_edge_attributes(G, name=&#39;spam&#39;, values=&#39;eggs&#39;)</span>
<span class="sd">        &gt;&gt;&gt; nx.set_edge_attributes(G, name=&#39;foo&#39;, values=&#39;bar&#39;)</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_edge_attributes(G, &#39;spam&#39;)) == 78</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_edge_attributes(G, &#39;foo&#39;)) == 78</span>
<span class="sd">        &gt;&gt;&gt; ut.nx_delete_edge_attr(G, [&#39;spam&#39;, &#39;foo&#39;], edges=[(1, 2)])</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_edge_attributes(G, &#39;spam&#39;)) == 77</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_edge_attributes(G, &#39;foo&#39;)) == 77</span>
<span class="sd">        &gt;&gt;&gt; ut.nx_delete_edge_attr(G, [&#39;spam&#39;])</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_edge_attributes(G, &#39;spam&#39;)) == 0</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_edge_attributes(G, &#39;foo&#39;)) == 77</span>

<span class="sd">    Doctest:</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; G = nx.MultiGraph()</span>
<span class="sd">        &gt;&gt;&gt; G.add_edges_from([(1, 2), (2, 3), (3, 4), (4, 5), (4, 5), (1, 2)])</span>
<span class="sd">        &gt;&gt;&gt; nx.set_edge_attributes(G, name=&#39;spam&#39;, values=&#39;eggs&#39;)</span>
<span class="sd">        &gt;&gt;&gt; nx.set_edge_attributes(G, name=&#39;foo&#39;, values=&#39;bar&#39;)</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_edge_attributes(G, &#39;spam&#39;)) == 6</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_edge_attributes(G, &#39;foo&#39;)) == 6</span>
<span class="sd">        &gt;&gt;&gt; ut.nx_delete_edge_attr(G, [&#39;spam&#39;, &#39;foo&#39;], edges=[(1, 2, 0)])</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_edge_attributes(G, &#39;spam&#39;)) == 5</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_edge_attributes(G, &#39;foo&#39;)) == 5</span>
<span class="sd">        &gt;&gt;&gt; ut.nx_delete_edge_attr(G, [&#39;spam&#39;])</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_edge_attributes(G, &#39;spam&#39;)) == 0</span>
<span class="sd">        &gt;&gt;&gt; assert len(nx.get_edge_attributes(G, &#39;foo&#39;)) == 5</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">removed</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="k">else</span> <span class="n">name</span>
    <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">():</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key_</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">][</span><span class="n">key_</span><span class="p">]</span>
                    <span class="n">removed</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key_</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">key_</span><span class="p">]</span>
                    <span class="n">removed</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
    <span class="k">return</span> <span class="n">removed</span></div>


<div class="viewcode-block" id="nx_delete_None_edge_attr"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_delete_None_edge_attr">[docs]</a><span class="k">def</span> <span class="nf">nx_delete_None_edge_attr</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">removed</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="n">graph</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">()))</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">edge</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                        <span class="n">removed</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">():</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">edge</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                        <span class="n">removed</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>
    <span class="k">return</span> <span class="n">removed</span></div>


<div class="viewcode-block" id="nx_delete_None_node_attr"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_delete_None_node_attr">[docs]</a><span class="k">def</span> <span class="nf">nx_delete_None_node_attr</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">removed</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="n">node_dict</span> <span class="o">=</span> <span class="n">nx_node_dict</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">node_dict</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="n">removed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
    <span class="k">return</span> <span class="n">removed</span></div>


<div class="viewcode-block" id="nx_set_default_node_attributes"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_set_default_node_attributes">[docs]</a><span class="k">def</span> <span class="nf">nx_set_default_node_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="n">unset_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">val</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">unset_nodes</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">val</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">unset_nodes</span><span class="p">}</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">)</span></div>


<div class="viewcode-block" id="nx_set_default_edge_attributes"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_set_default_edge_attributes">[docs]</a><span class="k">def</span> <span class="nf">nx_set_default_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="n">unset_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span> <span class="n">val</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">unset_edges</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">val</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">unset_edges</span><span class="p">}</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">values</span><span class="p">)</span></div>


<div class="viewcode-block" id="nx_get_default_edge_attributes"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_get_default_edge_attributes">[docs]</a><span class="k">def</span> <span class="nf">nx_get_default_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">edge_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
    <span class="n">partial_attr_dict</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="n">attr_dict</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_subset</span><span class="p">(</span><span class="n">partial_attr_dict</span><span class="p">,</span> <span class="n">edge_list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">attr_dict</span></div>


<div class="viewcode-block" id="nx_get_default_node_attributes"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_get_default_node_attributes">[docs]</a><span class="k">def</span> <span class="nf">nx_get_default_node_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">node_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="n">partial_attr_dict</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="n">attr_dict</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_subset</span><span class="p">(</span><span class="n">partial_attr_dict</span><span class="p">,</span> <span class="n">node_list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">attr_dict</span></div>


<div class="viewcode-block" id="nx_gen_node_values"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_gen_node_values">[docs]</a><span class="k">def</span> <span class="nf">nx_gen_node_values</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">util_const</span><span class="o">.</span><span class="n">NoParam</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates attributes values of specific nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">node_dict</span> <span class="o">=</span> <span class="n">nx_node_dict</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="n">util_const</span><span class="o">.</span><span class="n">NoParam</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">node_dict</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">node_dict</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">)</span></div>


<div class="viewcode-block" id="nx_gen_node_attrs"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_gen_node_attrs">[docs]</a><span class="k">def</span> <span class="nf">nx_gen_node_attrs</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">key</span><span class="p">,</span>
    <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default</span><span class="o">=</span><span class="n">util_const</span><span class="o">.</span><span class="n">NoParam</span><span class="p">,</span>
    <span class="n">on_missing</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">,</span>
    <span class="n">on_keyerr</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Improved generator version of nx.get_node_attributes</span>

<span class="sd">    Args:</span>
<span class="sd">        on_missing (str): Strategy for handling nodes missing from G.</span>
<span class="sd">            Can be {&#39;error&#39;, &#39;default&#39;, &#39;filter&#39;}.  defaults to &#39;error&#39;.</span>
<span class="sd">        on_keyerr (str): Strategy for handling keys missing from node dicts.</span>
<span class="sd">            Can be {&#39;error&#39;, &#39;default&#39;, &#39;filter&#39;}.  defaults to &#39;default&#39;</span>
<span class="sd">            if default is specified, otherwise defaults to &#39;error&#39;.</span>

<span class="sd">    Notes:</span>
<span class="sd">        strategies are:</span>
<span class="sd">            error - raises an error if key or node does not exist</span>
<span class="sd">            default - returns node, but uses value specified by default</span>
<span class="sd">            filter - skips the node</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; G = nx.Graph([(1, 2), (2, 3)])</span>
<span class="sd">        &gt;&gt;&gt; nx.set_node_attributes(G, name=&#39;part&#39;, values={1: &#39;bar&#39;, 3: &#39;baz&#39;})</span>
<span class="sd">        &gt;&gt;&gt; nodes = [1, 2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; #</span>
<span class="sd">        &gt;&gt;&gt; assert len(list(ut.nx_gen_node_attrs(G, &#39;part&#39;, default=None, on_missing=&#39;error&#39;, on_keyerr=&#39;default&#39;))) == 3</span>
<span class="sd">        &gt;&gt;&gt; assert len(list(ut.nx_gen_node_attrs(G, &#39;part&#39;, default=None, on_missing=&#39;error&#39;, on_keyerr=&#39;filter&#39;))) == 2</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_raises(KeyError, list, ut.nx_gen_node_attrs(G, &#39;part&#39;, on_missing=&#39;error&#39;, on_keyerr=&#39;error&#39;))</span>
<span class="sd">        &gt;&gt;&gt; #</span>
<span class="sd">        &gt;&gt;&gt; assert len(list(ut.nx_gen_node_attrs(G, &#39;part&#39;, nodes, default=None, on_missing=&#39;filter&#39;, on_keyerr=&#39;default&#39;))) == 3</span>
<span class="sd">        &gt;&gt;&gt; assert len(list(ut.nx_gen_node_attrs(G, &#39;part&#39;, nodes, default=None, on_missing=&#39;filter&#39;, on_keyerr=&#39;filter&#39;))) == 2</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_raises(KeyError, list, ut.nx_gen_node_attrs(G, &#39;part&#39;, nodes, on_missing=&#39;filter&#39;, on_keyerr=&#39;error&#39;))</span>
<span class="sd">        &gt;&gt;&gt; #</span>
<span class="sd">        &gt;&gt;&gt; assert len(list(ut.nx_gen_node_attrs(G, &#39;part&#39;, nodes, default=None, on_missing=&#39;default&#39;, on_keyerr=&#39;default&#39;))) == 4</span>
<span class="sd">        &gt;&gt;&gt; assert len(list(ut.nx_gen_node_attrs(G, &#39;part&#39;, nodes, default=None, on_missing=&#39;default&#39;, on_keyerr=&#39;filter&#39;))) == 2</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_raises(KeyError, list, ut.nx_gen_node_attrs(G, &#39;part&#39;, nodes, on_missing=&#39;default&#39;, on_keyerr=&#39;error&#39;))</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; # ALL CASES</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; G = nx.Graph([(1, 2), (2, 3)])</span>
<span class="sd">        &gt;&gt;&gt; nx.set_node_attributes(G, name=&#39;full&#39;, values={1: &#39;A&#39;, 2: &#39;B&#39;, 3: &#39;C&#39;})</span>
<span class="sd">        &gt;&gt;&gt; nx.set_node_attributes(G, name=&#39;part&#39;, values={1: &#39;bar&#39;, 3: &#39;baz&#39;})</span>
<span class="sd">        &gt;&gt;&gt; nodes = [1, 2, 3, 4]</span>
<span class="sd">        &gt;&gt;&gt; attrs = dict(ut.nx_gen_node_attrs(G, &#39;full&#39;))</span>
<span class="sd">        &gt;&gt;&gt; input_grid = {</span>
<span class="sd">        &gt;&gt;&gt;     &#39;nodes&#39;: [None, (1, 2, 3, 4)],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;key&#39;: [&#39;part&#39;, &#39;full&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;default&#39;: [util_const.NoParam, None],</span>
<span class="sd">        &gt;&gt;&gt; }</span>
<span class="sd">        &gt;&gt;&gt; inputs = ut.all_dict_combinations(input_grid)</span>
<span class="sd">        &gt;&gt;&gt; kw_grid = {</span>
<span class="sd">        &gt;&gt;&gt;     &#39;on_missing&#39;: [&#39;error&#39;, &#39;default&#39;, &#39;filter&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;on_keyerr&#39;: [&#39;error&#39;, &#39;default&#39;, &#39;filter&#39;],</span>
<span class="sd">        &gt;&gt;&gt; }</span>
<span class="sd">        &gt;&gt;&gt; kws = ut.all_dict_combinations(kw_grid)</span>
<span class="sd">        &gt;&gt;&gt; for in_ in inputs:</span>
<span class="sd">        &gt;&gt;&gt;     for kw in kws:</span>
<span class="sd">        &gt;&gt;&gt;         kw2 = ut.dict_union(kw, in_)</span>
<span class="sd">        &gt;&gt;&gt;         #print(kw2)</span>
<span class="sd">        &gt;&gt;&gt;         on_missing = kw[&#39;on_missing&#39;]</span>
<span class="sd">        &gt;&gt;&gt;         on_keyerr = kw[&#39;on_keyerr&#39;]</span>
<span class="sd">        &gt;&gt;&gt;         if on_keyerr == &#39;default&#39; and in_[&#39;default&#39;] is util_const.NoParam:</span>
<span class="sd">        &gt;&gt;&gt;             on_keyerr = &#39;error&#39;</span>
<span class="sd">        &gt;&gt;&gt;         will_miss = False</span>
<span class="sd">        &gt;&gt;&gt;         will_keyerr = False</span>
<span class="sd">        &gt;&gt;&gt;         if on_missing == &#39;error&#39;:</span>
<span class="sd">        &gt;&gt;&gt;             if in_[&#39;key&#39;] == &#39;part&#39; and in_[&#39;nodes&#39;] is not None:</span>
<span class="sd">        &gt;&gt;&gt;                 will_miss = True</span>
<span class="sd">        &gt;&gt;&gt;             if in_[&#39;key&#39;] == &#39;full&#39; and in_[&#39;nodes&#39;] is not None:</span>
<span class="sd">        &gt;&gt;&gt;                 will_miss = True</span>
<span class="sd">        &gt;&gt;&gt;         if on_keyerr == &#39;error&#39;:</span>
<span class="sd">        &gt;&gt;&gt;             if in_[&#39;key&#39;] == &#39;part&#39;:</span>
<span class="sd">        &gt;&gt;&gt;                 will_keyerr = True</span>
<span class="sd">        &gt;&gt;&gt;             if on_missing == &#39;default&#39;:</span>
<span class="sd">        &gt;&gt;&gt;                 if in_[&#39;key&#39;] == &#39;full&#39; and in_[&#39;nodes&#39;] is not None:</span>
<span class="sd">        &gt;&gt;&gt;                     will_keyerr = True</span>
<span class="sd">        &gt;&gt;&gt;         want_error = will_miss or will_keyerr</span>
<span class="sd">        &gt;&gt;&gt;         gen = ut.nx_gen_node_attrs(G, **kw2)</span>
<span class="sd">        &gt;&gt;&gt;         try:</span>
<span class="sd">        &gt;&gt;&gt;             attrs = list(gen)</span>
<span class="sd">        &gt;&gt;&gt;         except KeyError:</span>
<span class="sd">        &gt;&gt;&gt;             if not want_error:</span>
<span class="sd">        &gt;&gt;&gt;                 raise AssertionError(&#39;should not have errored&#39;)</span>
<span class="sd">        &gt;&gt;&gt;         else:</span>
<span class="sd">        &gt;&gt;&gt;             if want_error:</span>
<span class="sd">        &gt;&gt;&gt;                 raise AssertionError(&#39;should have errored&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">on_missing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">on_missing</span> <span class="o">=</span> <span class="s1">&#39;error&#39;</span>
    <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="n">util_const</span><span class="o">.</span><span class="n">NoParam</span> <span class="ow">and</span> <span class="n">on_keyerr</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="n">on_keyerr</span> <span class="o">=</span> <span class="s1">&#39;error&#39;</span>
    <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
    <span class="c1"># Generate `node_data` nodes and data dictionary</span>
    <span class="n">node_dict</span> <span class="o">=</span> <span class="n">nx_node_dict</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">on_missing</span> <span class="o">==</span> <span class="s1">&#39;error&#39;</span><span class="p">:</span>
        <span class="n">node_data</span> <span class="o">=</span> <span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">node_dict</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">on_missing</span> <span class="o">==</span> <span class="s1">&#39;filter&#39;</span><span class="p">:</span>
        <span class="n">node_data</span> <span class="o">=</span> <span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">node_dict</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">on_missing</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="n">node_data</span> <span class="o">=</span> <span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">node_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">{}))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
            <span class="s1">&#39;on_missing=</span><span class="si">{}</span><span class="s1"> must be error, filter or default&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">on_missing</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="c1"># Get `node_attrs` desired value out of dictionary</span>
    <span class="k">if</span> <span class="n">on_keyerr</span> <span class="o">==</span> <span class="s1">&#39;error&#39;</span><span class="p">:</span>
        <span class="n">node_attrs</span> <span class="o">=</span> <span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">node_data</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">on_keyerr</span> <span class="o">==</span> <span class="s1">&#39;filter&#39;</span><span class="p">:</span>
        <span class="n">node_attrs</span> <span class="o">=</span> <span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">node_data</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">on_keyerr</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="n">node_attrs</span> <span class="o">=</span> <span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">))</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">node_data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;on_keyerr=</span><span class="si">{}</span><span class="s1"> must be error filter or default&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">on_keyerr</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">node_attrs</span></div>


<div class="viewcode-block" id="nx_gen_edge_values"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_gen_edge_values">[docs]</a><span class="k">def</span> <span class="nf">nx_gen_edge_values</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">key</span><span class="p">,</span>
    <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default</span><span class="o">=</span><span class="n">util_const</span><span class="o">.</span><span class="n">NoParam</span><span class="p">,</span>
    <span class="n">on_missing</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">,</span>
    <span class="n">on_keyerr</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates attributes values of specific edges</span>

<span class="sd">    Args:</span>
<span class="sd">        on_missing (str): Strategy for handling nodes missing from G.</span>
<span class="sd">            Can be {&#39;error&#39;, &#39;default&#39;}.  defaults to &#39;error&#39;.</span>
<span class="sd">        on_keyerr (str): Strategy for handling keys missing from node dicts.</span>
<span class="sd">            Can be {&#39;error&#39;, &#39;default&#39;}.  defaults to &#39;default&#39;</span>
<span class="sd">            if default is specified, otherwise defaults to &#39;error&#39;.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">on_missing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">on_missing</span> <span class="o">=</span> <span class="s1">&#39;error&#39;</span>
    <span class="k">if</span> <span class="n">on_keyerr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">on_keyerr</span> <span class="o">=</span> <span class="s1">&#39;default&#39;</span>
    <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="n">util_const</span><span class="o">.</span><span class="n">NoParam</span> <span class="ow">and</span> <span class="n">on_keyerr</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="n">on_keyerr</span> <span class="o">=</span> <span class="s1">&#39;error&#39;</span>
    <span class="c1"># Generate `data_iter` edges and data dictionary</span>
    <span class="k">if</span> <span class="n">on_missing</span> <span class="o">==</span> <span class="s1">&#39;error&#39;</span><span class="p">:</span>
        <span class="n">data_iter</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">on_missing</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="n">data_iter</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">else</span> <span class="p">{}</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
            <span class="s1">&#39;on_missing=</span><span class="si">{}</span><span class="s1"> must be error, filter or default&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">on_missing</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="c1"># Get `value_iter` desired value out of dictionary</span>
    <span class="k">if</span> <span class="n">on_keyerr</span> <span class="o">==</span> <span class="s1">&#39;error&#39;</span><span class="p">:</span>
        <span class="n">value_iter</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data_iter</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">on_keyerr</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="n">value_iter</span> <span class="o">=</span> <span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">data_iter</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;on_keyerr=</span><span class="si">{}</span><span class="s1"> must be error or default&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">on_keyerr</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">value_iter</span></div>
    <span class="c1"># if default is util_const.NoParam:</span>
    <span class="c1">#     return (G.adj[u][v][key] for u, v in edges)</span>
    <span class="c1"># else:</span>
    <span class="c1">#     return (G.adj[u][v].get(key, default) for u, v in edges)</span>


<div class="viewcode-block" id="nx_gen_edge_attrs"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_gen_edge_attrs">[docs]</a><span class="k">def</span> <span class="nf">nx_gen_edge_attrs</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">key</span><span class="p">,</span>
    <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">default</span><span class="o">=</span><span class="n">util_const</span><span class="o">.</span><span class="n">NoParam</span><span class="p">,</span>
    <span class="n">on_missing</span><span class="o">=</span><span class="s1">&#39;error&#39;</span><span class="p">,</span>
    <span class="n">on_keyerr</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Improved generator version of nx.get_edge_attributes</span>

<span class="sd">    Args:</span>
<span class="sd">        on_missing (str): Strategy for handling nodes missing from G.</span>
<span class="sd">            Can be {&#39;error&#39;, &#39;default&#39;, &#39;filter&#39;}.  defaults to &#39;error&#39;.</span>
<span class="sd">            is on_missing is not error, then we allow any edge even if the</span>
<span class="sd">            endpoints are not in the graph.</span>
<span class="sd">        on_keyerr (str): Strategy for handling keys missing from node dicts.</span>
<span class="sd">            Can be {&#39;error&#39;, &#39;default&#39;, &#39;filter&#39;}.  defaults to &#39;default&#39;</span>
<span class="sd">            if default is specified, otherwise defaults to &#39;error&#39;.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; G = nx.Graph([(1, 2), (2, 3), (3, 4)])</span>
<span class="sd">        &gt;&gt;&gt; nx.set_edge_attributes(G, name=&#39;part&#39;, values={(1, 2): &#39;bar&#39;, (2, 3): &#39;baz&#39;})</span>
<span class="sd">        &gt;&gt;&gt; edges = [(1, 2), (2, 3), (3, 4), (4, 5)]</span>
<span class="sd">        &gt;&gt;&gt; func = ut.partial(ut.nx_gen_edge_attrs, G, &#39;part&#39;, default=None)</span>
<span class="sd">        &gt;&gt;&gt; #</span>
<span class="sd">        &gt;&gt;&gt; assert len(list(func(on_missing=&#39;error&#39;, on_keyerr=&#39;default&#39;))) == 3</span>
<span class="sd">        &gt;&gt;&gt; assert len(list(func(on_missing=&#39;error&#39;, on_keyerr=&#39;filter&#39;))) == 2</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_raises(KeyError, list, func(on_missing=&#39;error&#39;, on_keyerr=&#39;error&#39;))</span>
<span class="sd">        &gt;&gt;&gt; #</span>
<span class="sd">        &gt;&gt;&gt; assert len(list(func(edges, on_missing=&#39;filter&#39;, on_keyerr=&#39;default&#39;))) == 3</span>
<span class="sd">        &gt;&gt;&gt; assert len(list(func(edges, on_missing=&#39;filter&#39;, on_keyerr=&#39;filter&#39;))) == 2</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_raises(KeyError, list, func(edges, on_missing=&#39;filter&#39;, on_keyerr=&#39;error&#39;))</span>
<span class="sd">        &gt;&gt;&gt; #</span>
<span class="sd">        &gt;&gt;&gt; assert len(list(func(edges, on_missing=&#39;default&#39;, on_keyerr=&#39;default&#39;))) == 4</span>
<span class="sd">        &gt;&gt;&gt; assert len(list(func(edges, on_missing=&#39;default&#39;, on_keyerr=&#39;filter&#39;))) == 2</span>
<span class="sd">        &gt;&gt;&gt; ut.assert_raises(KeyError, list, func(edges, on_missing=&#39;default&#39;, on_keyerr=&#39;error&#39;))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">on_missing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">on_missing</span> <span class="o">=</span> <span class="s1">&#39;error&#39;</span>
    <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="n">util_const</span><span class="o">.</span><span class="n">NoParam</span> <span class="ow">and</span> <span class="n">on_keyerr</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="n">on_keyerr</span> <span class="o">=</span> <span class="s1">&#39;error&#39;</span>

    <span class="k">if</span> <span class="n">edges</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="c1"># uvk_iter = G.edges(keys=True)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span>
    <span class="c1"># Generate `edge_data` edges and data dictionary</span>
    <span class="k">if</span> <span class="n">on_missing</span> <span class="o">==</span> <span class="s1">&#39;error&#39;</span><span class="p">:</span>
        <span class="n">edge_data</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">])</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">on_missing</span> <span class="o">==</span> <span class="s1">&#39;filter&#39;</span><span class="p">:</span>
        <span class="n">edge_data</span> <span class="o">=</span> <span class="p">(((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">])</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span> <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">on_missing</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="n">edge_data</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">])</span> <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">else</span> <span class="p">((</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="p">{})</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;on_missing=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">on_missing</span><span class="p">))</span>
    <span class="c1"># Get `edge_attrs` desired value out of dictionary</span>
    <span class="k">if</span> <span class="n">on_keyerr</span> <span class="o">==</span> <span class="s1">&#39;error&#39;</span><span class="p">:</span>
        <span class="n">edge_attrs</span> <span class="o">=</span> <span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">edge_data</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">on_keyerr</span> <span class="o">==</span> <span class="s1">&#39;filter&#39;</span><span class="p">:</span>
        <span class="n">edge_attrs</span> <span class="o">=</span> <span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">edge_data</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">d</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">on_keyerr</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
        <span class="n">edge_attrs</span> <span class="o">=</span> <span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">))</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">edge_data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;on_keyerr=</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">on_keyerr</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">edge_attrs</span></div>

    <span class="c1"># if edges is None:</span>
    <span class="c1">#     if G.is_multigraph():</span>
    <span class="c1">#         edges_ = G.edges(keys=True, data=True)</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         edges_ = G.edges(data=True)</span>
    <span class="c1">#     if default is util_const.NoParam:</span>
    <span class="c1">#         return ((x[:-1], x[-1][key]) for x in edges_ if key in x[-1])</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         return ((x[:-1], x[-1].get(key, default)) for x in edges_)</span>

    <span class="c1"># else:</span>
    <span class="c1">#     if on_missing == &#39;error&#39;:</span>
    <span class="c1">#         uv_iter = edges</span>
    <span class="c1">#         uvd_iter = ((u, v, G.adj[u][v]) for u, v in uv_iter)</span>
    <span class="c1">#     elif on_missing == &#39;filter&#39;:</span>
    <span class="c1">#         # filter edges that don&#39;t exist</span>
    <span class="c1">#         uv_iter = (e for e in edges if G.has_edge(*e))</span>
    <span class="c1">#         uvd_iter = ((u, v, G.adj[u][v]) for u, v in uv_iter)</span>
    <span class="c1">#     elif on_missing == &#39;default&#39;:</span>
    <span class="c1">#         # Return default data as if it existed</span>
    <span class="c1">#         uvd_iter = (</span>
    <span class="c1">#             (u, v, G.adj[u][v])</span>
    <span class="c1">#             if G.has_edge(u, v) else</span>
    <span class="c1">#             (u, v, {})</span>
    <span class="c1">#             for u, v in uv_iter</span>
    <span class="c1">#         )</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         raise KeyError(&#39;on_missing={}&#39;.format(on_missing))</span>

    <span class="c1">#     if default is util_const.NoParam:</span>
    <span class="c1">#         # return (((u, v), d[key]) for u, v, d in uvd_iter if key in d)</span>
    <span class="c1">#         return (((u, v), d[key]) for u, v, d in uvd_iter)</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         uvd_iter = ((u, v, G.adj[u][v]) for u, v in uv_iter)</span>
    <span class="c1">#         return (((u, v), d.get(key, default)) for u, v, d in uvd_iter)</span>


<div class="viewcode-block" id="nx_from_node_edge"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_from_node_edge">[docs]</a><span class="k">def</span> <span class="nf">nx_from_node_edge</span><span class="p">(</span><span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">edges</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">nodes</span><span class="p">:</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">graph</span></div>


<div class="viewcode-block" id="nx_minimum_weight_component"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_minimum_weight_component">[docs]</a><span class="k">def</span> <span class="nf">nx_minimum_weight_component</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; A minimum weight component is an MST + all negative edges &quot;&quot;&quot;</span>
    <span class="n">mwc</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">minimum_spanning_tree</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>
    <span class="c1"># negative edges only reduce the total weight</span>
    <span class="n">neg_edges</span> <span class="o">=</span> <span class="p">(</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">nx_gen_edge_attrs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span> <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">mwc</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">neg_edges</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mwc</span></div>


<div class="viewcode-block" id="nx_from_matrix"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_from_matrix">[docs]</a><span class="k">def</span> <span class="nf">nx_from_matrix</span><span class="p">(</span><span class="n">weight_matrix</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remove_self</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>
    <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

    <span class="k">if</span> <span class="n">nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weight_matrix</span><span class="p">)))</span>
    <span class="n">weight_list</span> <span class="o">=</span> <span class="n">weight_matrix</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">flat_idxs_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">weight_matrix</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">multi_idxs_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">flat_idxs_</span><span class="p">,</span> <span class="n">weight_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Remove 0 weight edges</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">weight_list</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">weight_list</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">weight_list</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
    <span class="n">multi_idxs</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">multi_idxs_</span><span class="p">)),</span> <span class="n">flags</span><span class="p">)</span>
    <span class="n">edge_list</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">lmap</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">ut</span><span class="o">.</span><span class="n">unflat_take</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">multi_idxs</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">remove_self</span><span class="p">:</span>
        <span class="n">flags</span> <span class="o">=</span> <span class="p">[</span><span class="n">e1</span> <span class="o">!=</span> <span class="n">e2</span> <span class="k">for</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">edge_list</span><span class="p">]</span>
        <span class="n">edge_list</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
        <span class="n">weight_list</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">weight_list</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>

    <span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span>
    <span class="n">label_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="si">%.2f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">weight_list</span><span class="p">]</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="n">weight_list</span><span class="p">)))</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">edge_list</span><span class="p">,</span> <span class="n">label_list</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">graph</span></div>


<div class="viewcode-block" id="nx_ensure_agraph_color"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_ensure_agraph_color">[docs]</a><span class="k">def</span> <span class="nf">nx_ensure_agraph_color</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; changes colors to hex strings on graph attrs &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">wbia.plottool</span> <span class="k">import</span> <span class="n">color_funcs</span>
        <span class="kn">import</span> <span class="nn">wbia.plottool</span> <span class="k">as</span> <span class="nn">pt</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">plottool</span> <span class="k">import</span> <span class="n">color_funcs</span>
        <span class="kn">import</span> <span class="nn">wbia.plottool</span> <span class="k">as</span> <span class="nn">pt</span>
    <span class="c1"># import six</span>
    <span class="k">def</span> <span class="nf">_fix_agraph_color</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">orig_color</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">orig_color</span>
            <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">ensure_nonhex_color</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
                <span class="c1"># if isinstance(color, np.ndarray):</span>
                <span class="c1">#    color = color.tolist()</span>
                <span class="n">color</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">color_funcs</span><span class="o">.</span><span class="n">ensure_base255</span><span class="p">(</span><span class="n">color</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">color</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">color</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="mi">255</span><span class="p">)</span>
                <span class="n">color</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;#</span><span class="si">%02x%02x%02x</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">color</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;#</span><span class="si">%02x%02x%02x%02x</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">color</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">ex</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

            <span class="n">ut</span><span class="o">.</span><span class="n">printex</span><span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;orig_color&#39;</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">])</span>
            <span class="k">raise</span>

    <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">node_data</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">node_data</span>
        <span class="n">_fix_agraph_color</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">edge_data</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">edge_data</span>
        <span class="n">_fix_agraph_color</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>


<div class="viewcode-block" id="nx_edges"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_edges">[docs]</a><span class="k">def</span> <span class="nf">nx_edges</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">():</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="n">keys</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># if keys:</span>
        <span class="c1">#    edges = [e[0:2] + (0,) + e[:2] for e in edges]</span>
    <span class="k">return</span> <span class="n">edges</span></div>


<div class="viewcode-block" id="dag_longest_path"><a class="viewcode-back" href="../../utool.html#utool.util_graph.dag_longest_path">[docs]</a><span class="k">def</span> <span class="nf">dag_longest_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the longest path in a dag between two nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">source</span><span class="p">]</span>
    <span class="n">allpaths</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">all_simple_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
    <span class="n">longest_path</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">allpaths</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">longest_path</span><span class="p">):</span>
            <span class="n">longest_path</span> <span class="o">=</span> <span class="n">l</span>
    <span class="k">return</span> <span class="n">longest_path</span></div>


<div class="viewcode-block" id="testdata_graph"><a class="viewcode-back" href="../../utool.html#utool.util_graph.testdata_graph">[docs]</a><span class="k">def</span> <span class="nf">testdata_graph</span><span class="p">():</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns:</span>
<span class="sd">        tuple: (graph, G)</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_graph --exec-testdata_graph --show</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; (graph, G) = testdata_graph()</span>
<span class="sd">        &gt;&gt;&gt; import wbia.plottool as pt</span>
<span class="sd">        &gt;&gt;&gt; ut.ensureqt()</span>
<span class="sd">        &gt;&gt;&gt; pt.show_nx(G, layout=&#39;agraph&#39;)</span>
<span class="sd">        &gt;&gt;&gt; ut.show_if_requested()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="c1"># Define adjacency list</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span>
        <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">],</span>
        <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span>
        <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">],</span>
        <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">],</span>
        <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">],</span>
        <span class="s1">&#39;g&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">],</span>
        <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span>
        <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;j&#39;</span><span class="p">],</span>
        <span class="s1">&#39;j&#39;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="p">}</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span>
        <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span>
        <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span>
        <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">],</span>
        <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span>
    <span class="p">}</span>
    <span class="c1"># graph = {&#39;a&#39;: [&#39;b&#39;], &#39;b&#39;: [&#39;c&#39;], &#39;c&#39;: [&#39;d&#39;], &#39;d&#39;: [&#39;a&#39;]}</span>
    <span class="c1"># graph = {&#39;a&#39;: [&#39;b&#39;], &#39;b&#39;: [&#39;c&#39;], &#39;c&#39;: [&#39;d&#39;], &#39;d&#39;: [&#39;e&#39;], &#39;e&#39;: [&#39;a&#39;]}</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">],</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">],</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]}</span>
    <span class="c1"># graph = {&#39;a&#39;: [&#39;b&#39;], &#39;b&#39;: [&#39;c&#39;], &#39;c&#39;: [&#39;d&#39;], &#39;d&#39;: [&#39;e&#39;], &#39;e&#39;: [&#39;b&#39;]}</span>

    <span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span>
        <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span>
        <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">],</span>
        <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="p">}</span>  <span class="c1"># double pair in non-scc</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span>
        <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span>
        <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">],</span>
        <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">],</span>
    <span class="p">}</span>  <span class="c1"># double pair in non-scc</span>
    <span class="c1"># graph = {&#39;a&#39;: [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;], &#39;e&#39;: [&#39;d&#39;, &#39;f&#39;], &#39;f&#39;: [&#39;d&#39;, &#39;e&#39;], &#39;b&#39;: [], &#39;c&#39;: [], &#39;d&#39;: [&#39;e&#39;]}  # double pair in non-scc</span>
    <span class="c1"># graph = {&#39;a&#39;: [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;], &#39;e&#39;: [&#39;d&#39;, &#39;c&#39;], &#39;f&#39;: [&#39;d&#39;, &#39;e&#39;], &#39;b&#39;: [&#39;e&#39;], &#39;c&#39;: [&#39;e&#39;], &#39;d&#39;: [&#39;e&#39;]}  # double pair in non-scc</span>
    <span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">],</span>
        <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">],</span>
        <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">,</span> <span class="s1">&#39;e&#39;</span><span class="p">],</span>
        <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">],</span>
        <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">],</span>
        <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">],</span>
    <span class="p">}</span>  <span class="c1"># double pair in non-scc</span>
    <span class="c1"># Extract G = (V, E)</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">edges</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">([[(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="n">v2s</span><span class="p">]</span> <span class="k">for</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2s</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>

    <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">G</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">graph</span><span class="p">[</span><span class="s1">&#39;e&#39;</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">val</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">pass</span>
    <span class="k">return</span> <span class="n">graph</span><span class="p">,</span> <span class="n">G</span></div>


<div class="viewcode-block" id="dict_depth"><a class="viewcode-back" href="../../utool.html#utool.util_graph.dict_depth">[docs]</a><span class="k">def</span> <span class="nf">dict_depth</span><span class="p">(</span><span class="n">dict_</span><span class="p">,</span> <span class="n">accum</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dict_</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">accum</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">([</span><span class="n">dict_depth</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">accum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">dict_</span><span class="o">.</span><span class="n">items</span><span class="p">()])</span></div>


<div class="viewcode-block" id="edges_to_adjacency_list"><a class="viewcode-back" href="../../utool.html#utool.util_graph.edges_to_adjacency_list">[docs]</a><span class="k">def</span> <span class="nf">edges_to_adjacency_list</span><span class="p">(</span><span class="n">edges</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">children_</span><span class="p">,</span> <span class="n">parents_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">edges</span><span class="p">))</span>
    <span class="n">parent_to_children</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">group_items</span><span class="p">(</span><span class="n">parents_</span><span class="p">,</span> <span class="n">children_</span><span class="p">)</span>
    <span class="c1"># to_leafs = {tablename: path_to_leafs(tablename, parent_to_children)}</span>
    <span class="k">return</span> <span class="n">parent_to_children</span></div>


<div class="viewcode-block" id="paths_to_root"><a class="viewcode-back" href="../../utool.html#utool.util_graph.paths_to_root">[docs]</a><span class="k">def</span> <span class="nf">paths_to_root</span><span class="p">(</span><span class="n">tablename</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">child_to_parents</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_graph --exec-paths_to_root:0</span>
<span class="sd">        python -m utool.util_graph --exec-paths_to_root:1</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; child_to_parents = {</span>
<span class="sd">        &gt;&gt;&gt;     &#39;chip&#39;: [&#39;dummy_annot&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;chipmask&#39;: [&#39;dummy_annot&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;descriptor&#39;: [&#39;keypoint&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;fgweight&#39;: [&#39;keypoint&#39;, &#39;probchip&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;keypoint&#39;: [&#39;chip&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;notch&#39;: [&#39;dummy_annot&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;probchip&#39;: [&#39;dummy_annot&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;spam&#39;: [&#39;fgweight&#39;, &#39;chip&#39;, &#39;keypoint&#39;]</span>
<span class="sd">        &gt;&gt;&gt; }</span>
<span class="sd">        &gt;&gt;&gt; root = &#39;dummy_annot&#39;</span>
<span class="sd">        &gt;&gt;&gt; tablename = &#39;fgweight&#39;</span>
<span class="sd">        &gt;&gt;&gt; to_root = paths_to_root(tablename, root, child_to_parents)</span>
<span class="sd">        &gt;&gt;&gt; result = ut.repr3(to_root)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        {</span>
<span class="sd">            &#39;keypoint&#39;: {</span>
<span class="sd">                &#39;chip&#39;: {</span>
<span class="sd">                    &#39;dummy_annot&#39;: None,</span>
<span class="sd">                },</span>
<span class="sd">            },</span>
<span class="sd">            &#39;probchip&#39;: {</span>
<span class="sd">                &#39;dummy_annot&#39;: None,</span>
<span class="sd">            },</span>
<span class="sd">        }</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; root = u&#39;annotations&#39;</span>
<span class="sd">        &gt;&gt;&gt; tablename = u&#39;Notch_Tips&#39;</span>
<span class="sd">        &gt;&gt;&gt; child_to_parents = {</span>
<span class="sd">        &gt;&gt;&gt;     &#39;Block_Curvature&#39;: [</span>
<span class="sd">        &gt;&gt;&gt;         &#39;Trailing_Edge&#39;,</span>
<span class="sd">        &gt;&gt;&gt;     ],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;Has_Notch&#39;: [</span>
<span class="sd">        &gt;&gt;&gt;         &#39;annotations&#39;,</span>
<span class="sd">        &gt;&gt;&gt;     ],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;Notch_Tips&#39;: [</span>
<span class="sd">        &gt;&gt;&gt;         &#39;annotations&#39;,</span>
<span class="sd">        &gt;&gt;&gt;     ],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;Trailing_Edge&#39;: [</span>
<span class="sd">        &gt;&gt;&gt;         &#39;Notch_Tips&#39;,</span>
<span class="sd">        &gt;&gt;&gt;     ],</span>
<span class="sd">        &gt;&gt;&gt; }</span>
<span class="sd">        &gt;&gt;&gt; to_root = paths_to_root(tablename, root, child_to_parents)</span>
<span class="sd">        &gt;&gt;&gt; result = ut.repr3(to_root)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tablename</span> <span class="o">==</span> <span class="n">root</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">parents</span> <span class="o">=</span> <span class="n">child_to_parents</span><span class="p">[</span><span class="n">tablename</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">{</span><span class="n">parent</span><span class="p">:</span> <span class="n">paths_to_root</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">child_to_parents</span><span class="p">)</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">parents</span><span class="p">}</span></div>


<div class="viewcode-block" id="get_allkeys"><a class="viewcode-back" href="../../utool.html#utool.util_graph.get_allkeys">[docs]</a><span class="k">def</span> <span class="nf">get_allkeys</span><span class="p">(</span><span class="n">dict_</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dict_</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">subkeys</span> <span class="o">=</span> <span class="p">[[</span><span class="n">key</span><span class="p">]</span> <span class="o">+</span> <span class="n">get_allkeys</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">dict_</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
    <span class="k">return</span> <span class="n">ut</span><span class="o">.</span><span class="n">unique_ordered</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">subkeys</span><span class="p">))</span></div>


<div class="viewcode-block" id="traverse_path"><a class="viewcode-back" href="../../utool.html#utool.util_graph.traverse_path">[docs]</a><span class="k">def</span> <span class="nf">traverse_path</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">seen_</span><span class="p">,</span> <span class="n">allkeys</span><span class="p">,</span> <span class="n">mat</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="k">if</span> <span class="n">seen_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">seen_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">allkeys</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">sub_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">index</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_indexes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">subkeys</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">allkeys</span><span class="p">,</span> <span class="n">sub_indexes</span><span class="p">)</span>
        <span class="c1"># subkeys_ = ut.take(allkeys, sub_indexes)</span>
        <span class="c1"># subkeys = [subkey for subkey in subkeys_</span>
        <span class="c1">#            if subkey not in seen_]</span>
        <span class="c1"># for sk in subkeys:</span>
        <span class="c1">#     seen_.add(sk)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subkeys</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="n">subkey</span><span class="p">:</span> <span class="n">traverse_path</span><span class="p">(</span><span class="n">subkey</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">seen_</span><span class="p">,</span> <span class="n">allkeys</span><span class="p">,</span> <span class="n">mat</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">subkey</span> <span class="ow">in</span> <span class="n">subkeys</span>
            <span class="p">}</span>
    <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="reverse_path"><a class="viewcode-back" href="../../utool.html#utool.util_graph.reverse_path">[docs]</a><span class="k">def</span> <span class="nf">reverse_path</span><span class="p">(</span><span class="n">dict_</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">child_to_parents</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_graph --exec-reverse_path --show</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; child_to_parents = {</span>
<span class="sd">        &gt;&gt;&gt;     &#39;chip&#39;: [&#39;dummy_annot&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;chipmask&#39;: [&#39;dummy_annot&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;descriptor&#39;: [&#39;keypoint&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;fgweight&#39;: [&#39;keypoint&#39;, &#39;probchip&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;keypoint&#39;: [&#39;chip&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;notch&#39;: [&#39;dummy_annot&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;probchip&#39;: [&#39;dummy_annot&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     &#39;spam&#39;: [&#39;fgweight&#39;, &#39;chip&#39;, &#39;keypoint&#39;]</span>
<span class="sd">        &gt;&gt;&gt; }</span>
<span class="sd">        &gt;&gt;&gt; to_root = {</span>
<span class="sd">        &gt;&gt;&gt;     &#39;fgweight&#39;: {</span>
<span class="sd">        &gt;&gt;&gt;         &#39;keypoint&#39;: {</span>
<span class="sd">        &gt;&gt;&gt;             &#39;chip&#39;: {</span>
<span class="sd">        &gt;&gt;&gt;                 &#39;dummy_annot&#39;: None,</span>
<span class="sd">        &gt;&gt;&gt;             },</span>
<span class="sd">        &gt;&gt;&gt;         },</span>
<span class="sd">        &gt;&gt;&gt;         &#39;probchip&#39;: {</span>
<span class="sd">        &gt;&gt;&gt;             &#39;dummy_annot&#39;: None,</span>
<span class="sd">        &gt;&gt;&gt;         },</span>
<span class="sd">        &gt;&gt;&gt;     },</span>
<span class="sd">        &gt;&gt;&gt; }</span>
<span class="sd">        &gt;&gt;&gt; reversed_ = reverse_path(to_root, &#39;dummy_annot&#39;, child_to_parents)</span>
<span class="sd">        &gt;&gt;&gt; result = ut.repr3(reversed_)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        {</span>
<span class="sd">            &#39;dummy_annot&#39;: {</span>
<span class="sd">                &#39;chip&#39;: {</span>
<span class="sd">                    &#39;keypoint&#39;: {</span>
<span class="sd">                        &#39;fgweight&#39;: None,</span>
<span class="sd">                    },</span>
<span class="sd">                },</span>
<span class="sd">                &#39;probchip&#39;: {</span>
<span class="sd">                    &#39;fgweight&#39;: None,</span>
<span class="sd">                },</span>
<span class="sd">            },</span>
<span class="sd">        }</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Hacky but illustrative</span>
    <span class="c1"># TODO; implement non-hacky version</span>
    <span class="n">allkeys</span> <span class="o">=</span> <span class="n">get_allkeys</span><span class="p">(</span><span class="n">dict_</span><span class="p">)</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">allkeys</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">allkeys</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">allkeys</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">!=</span> <span class="n">root</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">child_to_parents</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="n">rx</span> <span class="o">=</span> <span class="n">allkeys</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
                <span class="n">cx</span> <span class="o">=</span> <span class="n">allkeys</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">rx</span><span class="p">][</span><span class="n">cx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">seen_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
    <span class="n">reversed_</span> <span class="o">=</span> <span class="p">{</span><span class="n">root</span><span class="p">:</span> <span class="n">traverse_path</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">seen_</span><span class="p">,</span> <span class="n">allkeys</span><span class="p">,</span> <span class="n">mat</span><span class="p">)}</span>
    <span class="k">return</span> <span class="n">reversed_</span></div>


<div class="viewcode-block" id="get_levels"><a class="viewcode-back" href="../../utool.html#utool.util_graph.get_levels">[docs]</a><span class="k">def</span> <span class="nf">get_levels</span><span class="p">(</span><span class="n">dict_</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DEPCIRATE</span>

<span class="sd">    Args:</span>
<span class="sd">        dict_ (dict_):  a dictionary</span>
<span class="sd">        n (int): (default = 0)</span>
<span class="sd">        levels (None): (default = None)</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_graph --test-get_levels --show</span>
<span class="sd">        python3 -m utool.util_graph --test-get_levels --show</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; from_root = {</span>
<span class="sd">        &gt;&gt;&gt;     &#39;dummy_annot&#39;: {</span>
<span class="sd">        &gt;&gt;&gt;         &#39;chip&#39;: {</span>
<span class="sd">        &gt;&gt;&gt;                 &#39;keypoint&#39;: {</span>
<span class="sd">        &gt;&gt;&gt;                             &#39;fgweight&#39;: None,</span>
<span class="sd">        &gt;&gt;&gt;                         },</span>
<span class="sd">        &gt;&gt;&gt;             },</span>
<span class="sd">        &gt;&gt;&gt;         &#39;probchip&#39;: {</span>
<span class="sd">        &gt;&gt;&gt;                 &#39;fgweight&#39;: None,</span>
<span class="sd">        &gt;&gt;&gt;             },</span>
<span class="sd">        &gt;&gt;&gt;     },</span>
<span class="sd">        &gt;&gt;&gt; }</span>
<span class="sd">        &gt;&gt;&gt; dict_ = from_root</span>
<span class="sd">        &gt;&gt;&gt; n = 0</span>
<span class="sd">        &gt;&gt;&gt; levels = None</span>
<span class="sd">        &gt;&gt;&gt; levels_ = get_levels(dict_, n, levels)</span>
<span class="sd">        &gt;&gt;&gt; result = ut.repr2(levels_, nl=1)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [</span>
<span class="sd">            [&#39;dummy_annot&#39;],</span>
<span class="sd">            [&#39;chip&#39;, &#39;probchip&#39;],</span>
<span class="sd">            [&#39;keypoint&#39;, &#39;fgweight&#39;],</span>
<span class="sd">            [&#39;fgweight&#39;],</span>
<span class="sd">        ]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">levels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">levels_</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dict_depth</span><span class="p">(</span><span class="n">dict_</span><span class="p">))]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">levels_</span> <span class="o">=</span> <span class="n">levels</span>
    <span class="k">if</span> <span class="n">dict_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">dict_</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">levels_</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">dict_</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
        <span class="n">get_levels</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">levels_</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">levels_</span></div>


<div class="viewcode-block" id="longest_levels"><a class="viewcode-back" href="../../utool.html#utool.util_graph.longest_levels">[docs]</a><span class="k">def</span> <span class="nf">longest_levels</span><span class="p">(</span><span class="n">levels_</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        levels_ (list):</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_graph --exec-longest_levels --show</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; levels_ = [</span>
<span class="sd">        &gt;&gt;&gt;     [&#39;dummy_annot&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     [&#39;chip&#39;, &#39;probchip&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     [&#39;keypoint&#39;, &#39;fgweight&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     [&#39;fgweight&#39;],</span>
<span class="sd">        &gt;&gt;&gt; ]</span>
<span class="sd">        &gt;&gt;&gt; new_levels = longest_levels(levels_)</span>
<span class="sd">        &gt;&gt;&gt; result = (&#39;new_levels = %s&#39; % (ut.repr2(new_levels, nl=1),))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        new_levels = [</span>
<span class="sd">            [&#39;dummy_annot&#39;],</span>
<span class="sd">            [&#39;chip&#39;, &#39;probchip&#39;],</span>
<span class="sd">            [&#39;keypoint&#39;],</span>
<span class="sd">            [&#39;fgweight&#39;],</span>
<span class="sd">        ]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">shortest_levels</span><span class="p">(</span><span class="n">levels_</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>
    <span class="c1"># seen_ = set([])</span>
    <span class="c1"># new_levels = []</span>
    <span class="c1"># for level in levels_[::-1]:</span>
    <span class="c1">#     new_level = [item for item in level if item not in seen_]</span>
    <span class="c1">#     seen_ = seen_.union(set(new_level))</span>
    <span class="c1">#     new_levels.append(new_level)</span>
    <span class="c1"># new_levels = new_levels[::-1]</span>
    <span class="c1"># return new_levels</span>


<div class="viewcode-block" id="shortest_levels"><a class="viewcode-back" href="../../utool.html#utool.util_graph.shortest_levels">[docs]</a><span class="k">def</span> <span class="nf">shortest_levels</span><span class="p">(</span><span class="n">levels_</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        levels_ (list):</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_graph --exec-shortest_levels --show</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; levels_ = [</span>
<span class="sd">        &gt;&gt;&gt;     [&#39;dummy_annot&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     [&#39;chip&#39;, &#39;probchip&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     [&#39;keypoint&#39;, &#39;fgweight&#39;],</span>
<span class="sd">        &gt;&gt;&gt;     [&#39;fgweight&#39;],</span>
<span class="sd">        &gt;&gt;&gt; ]</span>
<span class="sd">        &gt;&gt;&gt; new_levels = shortest_levels(levels_)</span>
<span class="sd">        &gt;&gt;&gt; result = (&#39;new_levels = %s&#39; % (ut.repr2(new_levels, nl=1),))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        new_levels = [</span>
<span class="sd">            [&#39;dummy_annot&#39;],</span>
<span class="sd">            [&#39;chip&#39;, &#39;probchip&#39;],</span>
<span class="sd">            [&#39;keypoint&#39;, &#39;fgweight&#39;],</span>
<span class="sd">        ]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">seen_</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
    <span class="n">new_levels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="n">levels_</span><span class="p">:</span>
        <span class="n">new_level</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">level</span> <span class="k">if</span> <span class="n">item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen_</span><span class="p">]</span>
        <span class="n">seen_</span> <span class="o">=</span> <span class="n">seen_</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">new_level</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_level</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_level</span><span class="p">)</span>
    <span class="n">new_levels</span> <span class="o">=</span> <span class="n">new_levels</span>
    <span class="k">return</span> <span class="n">new_levels</span></div>


<div class="viewcode-block" id="simplify_graph"><a class="viewcode-back" href="../../utool.html#utool.util_graph.simplify_graph">[docs]</a><span class="k">def</span> <span class="nf">simplify_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    strips out everything but connectivity</span>

<span class="sd">    Args:</span>
<span class="sd">        graph (nx.Graph):</span>

<span class="sd">    Returns:</span>
<span class="sd">        nx.Graph: new_graph</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python3 -m utool.util_graph simplify_graph --show</span>
<span class="sd">        python2 -m utool.util_graph simplify_graph --show</span>

<span class="sd">        python2 -c &quot;import networkx as nx; print(nx.__version__)&quot;</span>
<span class="sd">        python3 -c &quot;import networkx as nx; print(nx.__version__)&quot;</span>

<span class="sd">    Ignore:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; graph = nx.DiGraph([(&#39;a&#39;, &#39;b&#39;), (&#39;a&#39;, &#39;c&#39;), (&#39;a&#39;, &#39;e&#39;),</span>
<span class="sd">        &gt;&gt;&gt;                     (&#39;a&#39;, &#39;d&#39;), (&#39;b&#39;, &#39;d&#39;), (&#39;c&#39;, &#39;e&#39;),</span>
<span class="sd">        &gt;&gt;&gt;                     (&#39;d&#39;, &#39;e&#39;), (&#39;c&#39;, &#39;e&#39;), (&#39;c&#39;, &#39;d&#39;)])</span>
<span class="sd">        &gt;&gt;&gt; new_graph = simplify_graph(graph)</span>
<span class="sd">        &gt;&gt;&gt; result = ut.repr2(list(new_graph.edges()))</span>
<span class="sd">        &gt;&gt;&gt; #adj_list = sorted(list(nx.generate_adjlist(new_graph)))</span>
<span class="sd">        &gt;&gt;&gt; #result = ut.repr2(adj_list)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [(0, 1), (0, 2), (0, 3), (0, 4), (1, 3), (2, 3), (2, 4), (3, 4)]</span>

<span class="sd">        [&#39;0 1 2 3 4&#39;, &#39;1 3 4&#39;, &#39;2 4&#39;, &#39;3&#39;, &#39;4 3&#39;]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
    <span class="n">node_lookup</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">make_index_lookup</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">():</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>
    <span class="n">new_nodes</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">node_lookup</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">graph</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">():</span>
        <span class="n">new_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">node_lookup</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">node_lookup</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">e</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">{})</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">node_lookup</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">node_lookup</span><span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
    <span class="bp">cls</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="vm">__class__</span>
    <span class="n">new_graph</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">()</span>
    <span class="n">new_graph</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">new_nodes</span><span class="p">)</span>
    <span class="n">new_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_graph</span></div>


<div class="viewcode-block" id="subgraph_from_edges"><a class="viewcode-back" href="../../utool.html#utool.util_graph.subgraph_from_edges">[docs]</a><span class="k">def</span> <span class="nf">subgraph_from_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">edge_list</span><span class="p">,</span> <span class="n">ref_back</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates a networkx graph that is a subgraph of G</span>
<span class="sd">    defined by the list of edges in edge_list.</span>

<span class="sd">    Requires G to be a networkx MultiGraph or MultiDiGraph</span>
<span class="sd">    edge_list is a list of edges in either (u,v) or (u,v,d) form</span>
<span class="sd">    where u and v are nodes comprising an edge,</span>
<span class="sd">    and d would be a dictionary of edge attributes</span>

<span class="sd">    ref_back determines whether the created subgraph refers to back</span>
<span class="sd">    to the original graph and therefore changes to the subgraph&#39;s</span>
<span class="sd">    attributes also affect the original graph, or if it is to create a</span>
<span class="sd">    new copy of the original graph.</span>

<span class="sd">    References:</span>
<span class="sd">        http://stackoverflow.com/questions/16150557/nx-subgraph-from-edges</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO: support multi-di-graph</span>
    <span class="n">sub_nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">({</span><span class="n">y</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">edge_list</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]})</span>
    <span class="c1"># edge_list_no_data = [edge[0:2] for edge in edge_list]</span>
    <span class="n">multi_edge_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_list</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">ref_back</span><span class="p">:</span>
        <span class="n">G_sub</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">sub_nodes</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">G_sub</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">multi_edge_list</span><span class="p">:</span>
                <span class="n">G_sub</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">G_sub</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">sub_nodes</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">G_sub</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">edge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">multi_edge_list</span><span class="p">:</span>
                <span class="n">G_sub</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">G_sub</span></div>


<div class="viewcode-block" id="nx_node_dict"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_node_dict">[docs]</a><span class="k">def</span> <span class="nf">nx_node_dict</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;1&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;node&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span></div>


<div class="viewcode-block" id="all_multi_paths"><a class="viewcode-back" href="../../utool.html#utool.util_graph.all_multi_paths">[docs]</a><span class="k">def</span> <span class="nf">all_multi_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns specific paths along multi-edges from the source to this table.</span>
<span class="sd">    Multipaths are identified by edge keys.</span>

<span class="sd">    Returns all paths from source to target. This function treats multi-edges</span>
<span class="sd">    as distinct and returns the key value in each edge tuple that defines a</span>
<span class="sd">    path.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from dtool.depcache_control import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; from dtool.example_depcache import testdata_depc</span>
<span class="sd">        &gt;&gt;&gt; depc = testdata_depc()</span>
<span class="sd">        &gt;&gt;&gt; graph = depc.graph</span>
<span class="sd">        &gt;&gt;&gt; source = depc.root</span>
<span class="sd">        &gt;&gt;&gt; target = &#39;notchpair&#39;</span>
<span class="sd">        &gt;&gt;&gt; path_list1 = ut.all_multi_paths(graph, depc.root, &#39;notchpair&#39;)</span>
<span class="sd">        &gt;&gt;&gt; path_list2 = ut.all_multi_paths(graph, depc.root, &#39;spam&#39;)</span>
<span class="sd">        &gt;&gt;&gt; result1 = (&#39;path_list1 = %s&#39; % ut.repr3(path_list1, nl=1))</span>
<span class="sd">        &gt;&gt;&gt; result2 = (&#39;path_list2 = %s&#39; % ut.repr3(path_list2, nl=2))</span>
<span class="sd">        &gt;&gt;&gt; result = &#39;\n&#39;.join([result1, result2])</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        path_list1 = [</span>
<span class="sd">            [(&#39;dummy_annot&#39;, &#39;notch&#39;, 0), (&#39;notch&#39;, &#39;notchpair&#39;, 0)],</span>
<span class="sd">            [(&#39;dummy_annot&#39;, &#39;notch&#39;, 0), (&#39;notch&#39;, &#39;notchpair&#39;, 1)],</span>
<span class="sd">        ]</span>
<span class="sd">        path_list2 = [</span>
<span class="sd">            [</span>
<span class="sd">                (&#39;dummy_annot&#39;, &#39;chip&#39;, 0),</span>
<span class="sd">                (&#39;chip&#39;, &#39;keypoint&#39;, 0),</span>
<span class="sd">                (&#39;keypoint&#39;, &#39;fgweight&#39;, 0),</span>
<span class="sd">                (&#39;fgweight&#39;, &#39;spam&#39;, 0),</span>
<span class="sd">            ],</span>
<span class="sd">            [</span>
<span class="sd">                (&#39;dummy_annot&#39;, &#39;chip&#39;, 0),</span>
<span class="sd">                (&#39;chip&#39;, &#39;keypoint&#39;, 0),</span>
<span class="sd">                (&#39;keypoint&#39;, &#39;spam&#39;, 0),</span>
<span class="sd">            ],</span>
<span class="sd">            [</span>
<span class="sd">                (&#39;dummy_annot&#39;, &#39;chip&#39;, 0),</span>
<span class="sd">                (&#39;chip&#39;, &#39;spam&#39;, 0),</span>
<span class="sd">            ],</span>
<span class="sd">            [</span>
<span class="sd">                (&#39;dummy_annot&#39;, &#39;probchip&#39;, 0),</span>
<span class="sd">                (&#39;probchip&#39;, &#39;fgweight&#39;, 0),</span>
<span class="sd">                (&#39;fgweight&#39;, &#39;spam&#39;, 0),</span>
<span class="sd">            ],</span>
<span class="sd">        ]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path_multiedges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="n">nx_all_simple_edge_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">path_multiedges</span></div>


<div class="viewcode-block" id="reverse_path_edges"><a class="viewcode-back" href="../../utool.html#utool.util_graph.reverse_path_edges">[docs]</a><span class="k">def</span> <span class="nf">reverse_path_edges</span><span class="p">(</span><span class="n">edge_list</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edge_list</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="bfs_multi_edges"><a class="viewcode-back" href="../../utool.html#utool.util_graph.bfs_multi_edges">[docs]</a><span class="k">def</span> <span class="nf">bfs_multi_edges</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Produce edges in a breadth-first-search starting at source.</span>
<span class="sd">    -----</span>
<span class="sd">    Based on http://www.ics.uci.edu/~eppstein/PADS/BFS.py</span>
<span class="sd">    by D. Eppstein, July 2004.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">deque</span>
    <span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">partial</span>

    <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="n">edges_iter</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">keys</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

    <span class="nb">list</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges_iter</span><span class="p">(</span><span class="s1">&#39;multitest&#39;</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="n">visited_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">source</span><span class="p">])</span>
    <span class="c1"># visited_edges = set([])</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([(</span><span class="n">source</span><span class="p">,</span> <span class="n">edges_iter</span><span class="p">(</span><span class="n">source</span><span class="p">))])</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">parent</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">edge</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
            <span class="n">edge_nodata</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
            <span class="c1"># if edge_nodata not in visited_edges:</span>
            <span class="k">yield</span> <span class="n">edge</span>
            <span class="c1"># visited_edges.add(edge_nodata)</span>
            <span class="n">child</span> <span class="o">=</span> <span class="n">edge_nodata</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_nodes</span><span class="p">:</span>
                <span class="n">visited_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="n">edges_iter</span><span class="p">(</span><span class="n">child</span><span class="p">)))</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span></div>


<div class="viewcode-block" id="dfs_conditional"><a class="viewcode-back" href="../../utool.html#utool.util_graph.dfs_conditional">[docs]</a><span class="k">def</span> <span class="nf">dfs_conditional</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">can_cross</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *</span>
<span class="sd">        &gt;&gt;&gt; G = nx.Graph()</span>
<span class="sd">        &gt;&gt;&gt; G.add_edges_from([(1, 2), (2, 3), (3, 4), (4, 5)])</span>
<span class="sd">        &gt;&gt;&gt; G.adj[2][3][&#39;lava&#39;] = True</span>
<span class="sd">        &gt;&gt;&gt; G.adj[3][4][&#39;lava&#39;] = True</span>
<span class="sd">        &gt;&gt;&gt; def can_cross(G, edge, state):</span>
<span class="sd">        &gt;&gt;&gt;     # can only cross lava once, then your lava protection wears off</span>
<span class="sd">        &gt;&gt;&gt;     data = G.get_edge_data(*edge)</span>
<span class="sd">        &gt;&gt;&gt;     lava = int(data.get(&#39;lava&#39;, False))</span>
<span class="sd">        &gt;&gt;&gt;     if not lava or state == 0:</span>
<span class="sd">        &gt;&gt;&gt;         return True, state + lava</span>
<span class="sd">        &gt;&gt;&gt;     return False, lava</span>
<span class="sd">        &gt;&gt;&gt; assert 5 not in dfs_conditional(G, 1, state=0, can_cross=can_cross)</span>
<span class="sd">        &gt;&gt;&gt; G.adj[3][4][&#39;lava&#39;] = False</span>
<span class="sd">        &gt;&gt;&gt; assert 5 in dfs_conditional(G, 1, state=0, can_cross=can_cross)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># stack based version</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">{</span><span class="n">source</span><span class="p">}</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="n">source</span><span class="p">,</span> <span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">source</span><span class="p">]),</span> <span class="n">state</span><span class="p">)]</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">parent</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">child</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">edge</span> <span class="o">=</span> <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
                <span class="n">flag</span><span class="p">,</span> <span class="n">new_state</span> <span class="o">=</span> <span class="n">can_cross</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">edge</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">child</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="nb">iter</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">child</span><span class="p">]),</span> <span class="n">new_state</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span></div>


<div class="viewcode-block" id="bfs_conditional"><a class="viewcode-back" href="../../utool.html#utool.util_graph.bfs_conditional">[docs]</a><span class="k">def</span> <span class="nf">bfs_conditional</span><span class="p">(</span>
    <span class="n">G</span><span class="p">,</span>
    <span class="n">source</span><span class="p">,</span>
    <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">keys</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">yield_nodes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">yield_if</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">continue_if</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">visited_nodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">yield_source</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Produce edges in a breadth-first-search starting at source, but only return</span>
<span class="sd">    nodes that satisfiy a condition, and only iterate past a node if it</span>
<span class="sd">    satisfies a different condition.</span>

<span class="sd">    conditions are callables that take (G, child, edge) and return true or false</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_graph bfs_conditional</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # DISABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; G = nx.Graph()</span>
<span class="sd">        &gt;&gt;&gt; G.add_edges_from([(1, 2), (1, 3), (2, 3), (2, 4)])</span>
<span class="sd">        &gt;&gt;&gt; continue_if = lambda G, child, edge: True</span>
<span class="sd">        &gt;&gt;&gt; result = list(ut.bfs_conditional(G, 1, yield_nodes=False))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [(1, 2), (1, 3), (2, 1), (2, 3), (2, 4), (3, 1), (3, 2), (4, 2)]</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; import networkx as nx</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; G = nx.Graph()</span>
<span class="sd">        &gt;&gt;&gt; continue_if = lambda G, child, edge: (child % 2 == 0)</span>
<span class="sd">        &gt;&gt;&gt; yield_if = lambda G, child, edge: (child % 2 == 1)</span>
<span class="sd">        &gt;&gt;&gt; G.add_edges_from([(0, 1), (1, 3), (3, 5), (5, 10),</span>
<span class="sd">        &gt;&gt;&gt;                   (4, 3), (3, 6),</span>
<span class="sd">        &gt;&gt;&gt;                   (0, 2), (2, 4), (4, 6), (6, 10)])</span>
<span class="sd">        &gt;&gt;&gt; result = list(ut.bfs_conditional(G, 0, continue_if=continue_if,</span>
<span class="sd">        &gt;&gt;&gt;                                  yield_if=yield_if))</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        [1, 3, 5]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">reverse</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;reverse&#39;</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">):</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">keys</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>

    <span class="n">queue</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">deque</span><span class="p">([])</span>

    <span class="k">if</span> <span class="n">visited_nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">visited_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">visited_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">visited_nodes</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">source</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">yield_nodes</span> <span class="ow">and</span> <span class="n">yield_source</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">source</span>
        <span class="n">visited_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="n">new_edges</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_edges</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">source</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">))</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">parent</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">queue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
            <span class="n">child</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">yield_nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_nodes</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">yield_if</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">yield_if</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">child</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">yield_if</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">yield_if</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">edge</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited_nodes</span><span class="p">:</span>
                <span class="n">visited_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="c1"># Add new children to queue if the condition is satisfied</span>
                <span class="k">if</span> <span class="n">continue_if</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">continue_if</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
                    <span class="n">new_edges</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_edges</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="n">new_edges</span><span class="p">))</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span></div>


<div class="viewcode-block" id="color_nodes"><a class="viewcode-back" href="../../utool.html#utool.util_graph.color_nodes">[docs]</a><span class="k">def</span> <span class="nf">color_nodes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">labelattr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="n">brightness</span><span class="o">=</span><span class="mf">0.878</span><span class="p">,</span> <span class="n">outof</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sat_adjust</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Colors edges and nodes by nid &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">wbia.plottool</span> <span class="k">as</span> <span class="nn">pt</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">wbia.plottool</span> <span class="k">as</span> <span class="nn">pt</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">node_to_lbl</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">labelattr</span><span class="p">)</span>
    <span class="n">unique_lbls</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">node_to_lbl</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    <span class="n">ncolors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_lbls</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">outof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ncolors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">unique_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">pt</span><span class="o">.</span><span class="n">LIGHT_BLUE</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">ncolors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># https://matplotlib.org/examples/color/named_colors.html</span>
            <span class="n">unique_colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;royalblue&#39;</span><span class="p">,</span> <span class="s1">&#39;orange&#39;</span><span class="p">]</span>
            <span class="n">unique_colors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">pt</span><span class="o">.</span><span class="n">color_funcs</span><span class="o">.</span><span class="n">ensure_base01</span><span class="p">,</span> <span class="n">unique_colors</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">unique_colors</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">distinct_colors</span><span class="p">(</span><span class="n">ncolors</span><span class="p">,</span> <span class="n">brightness</span><span class="o">=</span><span class="n">brightness</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">unique_colors</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">distinct_colors</span><span class="p">(</span><span class="n">outof</span><span class="p">,</span> <span class="n">brightness</span><span class="o">=</span><span class="n">brightness</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sat_adjust</span><span class="p">:</span>
        <span class="n">unique_colors</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">pt</span><span class="o">.</span><span class="n">color_funcs</span><span class="o">.</span><span class="n">adjust_hsv_of_rgb</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sat_adjust</span><span class="o">=</span><span class="n">sat_adjust</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">unique_colors</span>
        <span class="p">]</span>
    <span class="c1"># Find edges and aids strictly between two nids</span>
    <span class="k">if</span> <span class="n">outof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">lbl_to_color</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="n">unique_lbls</span><span class="p">,</span> <span class="n">unique_colors</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gray</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">color_funcs</span><span class="o">.</span><span class="n">ensure_base01</span><span class="p">(</span><span class="s1">&#39;lightgray&#39;</span><span class="p">)</span>
        <span class="n">unique_colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">gray</span><span class="p">]</span> <span class="o">+</span> <span class="n">unique_colors</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">unique_lbls</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">node_to_lbl</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">map_vals</span><span class="p">(</span><span class="k">lambda</span> <span class="n">nid</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nid</span> <span class="o">-</span> <span class="n">offset</span><span class="p">),</span> <span class="n">node_to_lbl</span><span class="p">)</span>
        <span class="n">lbl_to_color</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dzip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">outof</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">unique_colors</span><span class="p">)</span>
    <span class="n">node_to_color</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">map_vals</span><span class="p">(</span><span class="n">lbl_to_color</span><span class="p">,</span> <span class="n">node_to_lbl</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">node_to_color</span><span class="p">)</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">nx_ensure_agraph_color</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span></div>


<div class="viewcode-block" id="graph_info"><a class="viewcode-back" href="../../utool.html#utool.util_graph.graph_info">[docs]</a><span class="k">def</span> <span class="nf">graph_info</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stats</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">node_dict</span> <span class="o">=</span> <span class="n">nx_node_dict</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">node_attrs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">node_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
    <span class="n">edge_attrs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">take_column</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">stats</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">utool</span>

        <span class="k">with</span> <span class="n">utool</span><span class="o">.</span><span class="n">embed_on_exception_context</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

            <span class="n">node_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">node_attrs</span><span class="p">)</span>
            <span class="n">edge_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">edge_attrs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ut</span><span class="o">.</span><span class="n">delete_dict_keys</span><span class="p">(</span><span class="n">node_df</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)</span>
                <span class="n">ut</span><span class="o">.</span><span class="n">delete_dict_keys</span><span class="p">(</span><span class="n">edge_df</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)</span>
            <span class="c1"># Not really histograms anymore</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">node_attr_hist</span> <span class="o">=</span> <span class="n">node_df</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">node_attr_hist</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">edge_attr_hist</span> <span class="o">=</span> <span class="n">edge_df</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">edge_attr_hist</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">key_order</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;25%&#39;</span><span class="p">,</span> <span class="s1">&#39;50%&#39;</span><span class="p">,</span> <span class="s1">&#39;75%&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">]</span>
            <span class="n">node_attr_hist</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">map_dict_vals</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ut</span><span class="o">.</span><span class="n">order_dict_by</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key_order</span><span class="p">),</span> <span class="n">node_attr_hist</span>
            <span class="p">)</span>
            <span class="n">edge_attr_hist</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">map_dict_vals</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">ut</span><span class="o">.</span><span class="n">order_dict_by</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">key_order</span><span class="p">),</span> <span class="n">edge_attr_hist</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">node_attr_hist</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_hist</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">([</span><span class="n">attr</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">node_attrs</span><span class="p">]))</span>
        <span class="n">edge_attr_hist</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_hist</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">flatten</span><span class="p">([</span><span class="n">attr</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">edge_attrs</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ut</span><span class="o">.</span><span class="n">delete_dict_keys</span><span class="p">(</span><span class="n">edge_attr_hist</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)</span>
            <span class="n">ut</span><span class="o">.</span><span class="n">delete_dict_keys</span><span class="p">(</span><span class="n">node_attr_hist</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)</span>
    <span class="n">node_type_hist</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">dict_hist</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())))</span>
    <span class="n">info_dict</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">odict</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;directed&#39;</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">is_directed</span><span class="p">()),</span>
            <span class="p">(</span><span class="s1">&#39;multi&#39;</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">is_multigraph</span><span class="p">()),</span>
            <span class="p">(</span><span class="s1">&#39;num_nodes&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;num_edges&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">edges</span><span class="p">()))),</span>
            <span class="p">(</span><span class="s1">&#39;edge_attr_hist&#39;</span><span class="p">,</span> <span class="n">ut</span><span class="o">.</span><span class="n">sort_dict</span><span class="p">(</span><span class="n">edge_attr_hist</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;node_attr_hist&#39;</span><span class="p">,</span> <span class="n">ut</span><span class="o">.</span><span class="n">sort_dict</span><span class="p">(</span><span class="n">node_attr_hist</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;node_type_hist&#39;</span><span class="p">,</span> <span class="n">ut</span><span class="o">.</span><span class="n">sort_dict</span><span class="p">(</span><span class="n">node_type_hist</span><span class="p">)),</span>
            <span class="p">(</span><span class="s1">&#39;graph_attrs&#39;</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">graph</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;graph_name&#39;</span><span class="p">,</span> <span class="n">graph</span><span class="o">.</span><span class="n">name</span><span class="p">),</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="c1"># unique_attrs = ut.map_dict_vals(ut.unique, ut.dict_accum(*node_attrs))</span>
    <span class="c1"># ut.dict_isect_combine(*node_attrs))</span>
    <span class="c1"># [list(attrs.keys())]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ut</span><span class="o">.</span><span class="n">repr3</span><span class="p">(</span><span class="n">info_dict</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">info_dict</span></div>


<div class="viewcode-block" id="get_graph_bounding_box"><a class="viewcode-back" href="../../utool.html#utool.util_graph.get_graph_bounding_box">[docs]</a><span class="k">def</span> <span class="nf">get_graph_bounding_box</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="c1"># import utool as ut</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">vtool</span> <span class="k">as</span> <span class="nn">vt</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">vtool</span> <span class="k">as</span> <span class="nn">vt</span>
    <span class="c1"># nx.get_node_attrs = nx.get_node_attributes</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="c1"># pos_list = nx_gen_node_values(graph, &#39;pos&#39;, nodes, default=(0, 0))</span>
    <span class="c1"># shape_list = nx_gen_node_values(graph, &#39;size&#39;, nodes, default=(1, 1))</span>
    <span class="n">shape_list</span> <span class="o">=</span> <span class="n">nx_gen_node_values</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
    <span class="n">pos_list</span> <span class="o">=</span> <span class="n">nx_gen_node_values</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s1">&#39;pos&#39;</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

    <span class="n">node_extents</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span>
            <span class="n">vt</span><span class="o">.</span><span class="n">extent_from_bbox</span><span class="p">(</span><span class="n">vt</span><span class="o">.</span><span class="n">bbox_from_center_wh</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">wh</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">xy</span><span class="p">,</span> <span class="n">wh</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pos_list</span><span class="p">,</span> <span class="n">shape_list</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="n">tl_x</span><span class="p">,</span> <span class="n">br_x</span><span class="p">,</span> <span class="n">tl_y</span><span class="p">,</span> <span class="n">br_y</span> <span class="o">=</span> <span class="n">node_extents</span><span class="o">.</span><span class="n">T</span>
    <span class="n">extent</span> <span class="o">=</span> <span class="n">tl_x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">br_x</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">tl_y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">br_y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">bbox</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">bbox_from_extent</span><span class="p">(</span><span class="n">extent</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">bbox</span></div>


<div class="viewcode-block" id="translate_graph"><a class="viewcode-back" href="../../utool.html#utool.util_graph.translate_graph">[docs]</a><span class="k">def</span> <span class="nf">translate_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">t_xy</span><span class="p">):</span>
    <span class="c1"># import utool as ut</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">node_pos_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">node_pos_attrs</span><span class="p">:</span>
        <span class="n">attrdict</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="n">attrdict</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">t_xy</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">attrdict</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">attr</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">attrdict</span><span class="p">)</span>
    <span class="n">edge_pos_attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;ctrl_pts&#39;</span><span class="p">,</span> <span class="s1">&#39;end_pt&#39;</span><span class="p">,</span> <span class="s1">&#39;head_lp&#39;</span><span class="p">,</span> <span class="s1">&#39;lp&#39;</span><span class="p">,</span> <span class="s1">&#39;start_pt&#39;</span><span class="p">,</span> <span class="s1">&#39;tail_lp&#39;</span><span class="p">]</span>
    <span class="n">ut</span><span class="o">.</span><span class="n">nx_delete_None_edge_attr</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">edge_pos_attrs</span><span class="p">:</span>
        <span class="n">attrdict</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">get_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
        <span class="n">attrdict</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">node</span><span class="p">:</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">t_xy</span> <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">pos</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">attrdict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_edge_attributes</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">attr</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="n">attrdict</span><span class="p">)</span></div>


<div class="viewcode-block" id="translate_graph_to_origin"><a class="viewcode-back" href="../../utool.html#utool.util_graph.translate_graph_to_origin">[docs]</a><span class="k">def</span> <span class="nf">translate_graph_to_origin</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">get_graph_bounding_box</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="n">translate_graph</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span><span class="p">))</span></div>


<div class="viewcode-block" id="stack_graphs"><a class="viewcode-back" href="../../utool.html#utool.util_graph.stack_graphs">[docs]</a><span class="k">def</span> <span class="nf">stack_graphs</span><span class="p">(</span><span class="n">graph_list</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pad</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">graph_list_</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">graph_list</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">graph_list_</span><span class="p">:</span>
        <span class="n">translate_graph_to_origin</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="n">bbox_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">get_graph_bounding_box</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">graph_list_</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">vert</span><span class="p">:</span>
        <span class="n">dim1</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="n">dim2</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dim1</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">dim2</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">dim1_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bbox</span><span class="p">[</span><span class="n">dim1</span><span class="p">]</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bbox_list</span><span class="p">])</span>
    <span class="n">dim2_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bbox</span><span class="p">[</span><span class="n">dim2</span><span class="p">]</span> <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bbox_list</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">pad</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dim1_list</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">offset1_list</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">cumsum</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">d</span> <span class="o">+</span> <span class="n">pad</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dim1_list</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
    <span class="n">max_dim2</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dim2_list</span><span class="p">)</span>
    <span class="n">offset2_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">max_dim2</span> <span class="o">-</span> <span class="n">d2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">d2</span> <span class="ow">in</span> <span class="n">dim2_list</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">vert</span><span class="p">:</span>
        <span class="n">t_xy_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">d2</span><span class="p">,</span> <span class="n">d1</span><span class="p">)</span> <span class="k">for</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">offset1_list</span><span class="p">,</span> <span class="n">offset2_list</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t_xy_list</span> <span class="o">=</span> <span class="p">[(</span><span class="n">d1</span><span class="p">,</span> <span class="n">d2</span><span class="p">)</span> <span class="k">for</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">offset1_list</span><span class="p">,</span> <span class="n">offset2_list</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">t_xy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">graph_list_</span><span class="p">,</span> <span class="n">t_xy_list</span><span class="p">):</span>
        <span class="n">translate_graph</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">t_xy</span><span class="p">)</span>
        <span class="n">nx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;pin&#39;</span><span class="p">,</span> <span class="n">values</span><span class="o">=</span><span class="s1">&#39;true&#39;</span><span class="p">)</span>

    <span class="n">new_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">compose_all</span><span class="p">(</span><span class="n">graph_list_</span><span class="p">)</span>
    <span class="c1"># pt.show_nx(new_graph, layout=&#39;custom&#39;, node_labels=False, as_directed=False)  # NOQA</span>
    <span class="k">return</span> <span class="n">new_graph</span></div>


<div class="viewcode-block" id="nx_contracted_nodes"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_contracted_nodes">[docs]</a><span class="k">def</span> <span class="nf">nx_contracted_nodes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">self_loops</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    copy of networkx function with inplace modification</span>
<span class="sd">    TODO: commit to networkx</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>

    <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">is_directed</span><span class="p">():</span>
        <span class="n">in_edges</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">in_edges</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">self_loops</span> <span class="ow">or</span> <span class="n">w</span> <span class="o">!=</span> <span class="n">u</span>
        <span class="p">)</span>
        <span class="n">out_edges</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">out_edges</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">self_loops</span> <span class="ow">or</span> <span class="n">w</span> <span class="o">!=</span> <span class="n">u</span>
        <span class="p">)</span>
        <span class="n">new_edges</span> <span class="o">=</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">in_edges</span><span class="p">,</span> <span class="n">out_edges</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_edges</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="n">self_loops</span> <span class="ow">or</span> <span class="n">w</span> <span class="o">!=</span> <span class="n">u</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">G</span>
        <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">node_dict</span> <span class="o">=</span> <span class="n">nx_node_dict</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="n">v_data</span> <span class="o">=</span> <span class="n">node_dict</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
    <span class="n">H</span><span class="o">.</span><span class="n">remove_node</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
    <span class="n">H</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">new_edges</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;contraction&#39;</span> <span class="ow">in</span> <span class="n">node_dict</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
        <span class="n">node_dict</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;contraction&#39;</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">v_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">node_dict</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;contraction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">:</span> <span class="n">v_data</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">H</span></div>


<div class="viewcode-block" id="approx_min_num_components"><a class="viewcode-back" href="../../utool.html#utool.util_graph.approx_min_num_components">[docs]</a><span class="k">def</span> <span class="nf">approx_min_num_components</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">negative_edges</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find approximate minimum number of connected components possible</span>
<span class="sd">    Each edge represents that two nodes must be separated</span>

<span class="sd">    This code doesn&#39;t solve the problem. The problem is NP-complete and</span>
<span class="sd">    reduces to minimum clique cover (MCC). This is only an approximate</span>
<span class="sd">    solution. Not sure what the approximation ratio is.</span>

<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_graph approx_min_num_components</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; nodes = [1, 2, 3, 4, 5, 6, 7, 8, 9]</span>
<span class="sd">        &gt;&gt;&gt; edges = [(1, 2), (2, 3), (3, 1),</span>
<span class="sd">        &gt;&gt;&gt;          (4, 5), (5, 6), (6, 4),</span>
<span class="sd">        &gt;&gt;&gt;          (7, 8), (8, 9), (9, 7),</span>
<span class="sd">        &gt;&gt;&gt;          (1, 4), (4, 7), (7, 1),</span>
<span class="sd">        &gt;&gt;&gt;         ]</span>
<span class="sd">        &gt;&gt;&gt; g_pos = nx.Graph()</span>
<span class="sd">        &gt;&gt;&gt; g_pos.add_edges_from(edges)</span>
<span class="sd">        &gt;&gt;&gt; g_neg = nx.complement(g_pos)</span>
<span class="sd">        &gt;&gt;&gt; #import wbia.plottool as pt</span>
<span class="sd">        &gt;&gt;&gt; #pt.qt4ensure()</span>
<span class="sd">        &gt;&gt;&gt; #pt.show_nx(g_pos)</span>
<span class="sd">        &gt;&gt;&gt; #pt.show_nx(g_neg)</span>
<span class="sd">        &gt;&gt;&gt; negative_edges = g_neg.edges()</span>
<span class="sd">        &gt;&gt;&gt; nodes = [1, 2, 3, 4, 5, 6, 7]</span>
<span class="sd">        &gt;&gt;&gt; negative_edges = [(1, 2), (2, 3), (4, 5)]</span>
<span class="sd">        &gt;&gt;&gt; result = approx_min_num_components(nodes, negative_edges)</span>
<span class="sd">        &gt;&gt;&gt; print(result)</span>
<span class="sd">        2</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>

    <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">g_neg</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">g_neg</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span>
    <span class="n">g_neg</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">negative_edges</span><span class="p">)</span>

    <span class="c1"># Collapse all nodes with degree 0</span>
    <span class="k">if</span> <span class="n">nx</span><span class="o">.</span><span class="n">__version__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;2&#39;</span><span class="p">):</span>
        <span class="n">deg0_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">g_neg</span><span class="o">.</span><span class="n">degree</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">deg0_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">g_neg</span><span class="o">.</span><span class="n">degree_iter</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ut</span><span class="o">.</span><span class="n">itertwo</span><span class="p">(</span><span class="n">deg0_nodes</span><span class="p">):</span>
        <span class="n">nx_contracted_nodes</span><span class="p">(</span><span class="n">g_neg</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># g_neg = nx.contracted_nodes(g_neg, v, u, self_loops=False)</span>

    <span class="c1"># Initialize unused nodes to be everything</span>
    <span class="n">unused</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">g_neg</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
    <span class="c1"># complement of the graph contains all possible positive edges</span>
    <span class="n">g_pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">complement</span><span class="p">(</span><span class="n">g_neg</span><span class="p">)</span>

    <span class="k">if</span> <span class="kc">False</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">networkx.algorithms.approximation</span> <span class="k">import</span> <span class="n">clique</span>

        <span class="n">maxiset</span><span class="p">,</span> <span class="n">cliques</span> <span class="o">=</span> <span class="n">clique</span><span class="o">.</span><span class="n">clique_removal</span><span class="p">(</span><span class="n">g_pos</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cliques</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">num</span>

    <span class="c1"># Iterate until we have used all nodes</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">unused</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Seed a new &quot;minimum component&quot;</span>
        <span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Grab a random unused node n1</span>
        <span class="c1"># idx1 = np.random.randint(0, len(unused))</span>
        <span class="n">idx1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">unused</span><span class="p">[</span><span class="n">idx1</span><span class="p">]</span>
        <span class="n">unused</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
        <span class="n">neigbs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">g_pos</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">n1</span><span class="p">))</span>
        <span class="n">neigbs</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">isect</span><span class="p">(</span><span class="n">neigbs</span><span class="p">,</span> <span class="n">unused</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">neigbs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Find node n2, that n1 could be connected to</span>
            <span class="c1"># idx2 = np.random.randint(0, len(neigbs))</span>
            <span class="n">idx2</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="n">neigbs</span><span class="p">[</span><span class="n">idx2</span><span class="p">]</span>
            <span class="n">unused</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>
            <span class="c1"># Collapse negative information of n1 and n2</span>
            <span class="n">g_neg</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">contracted_nodes</span><span class="p">(</span><span class="n">g_neg</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span>
            <span class="c1"># Compute new possible positive edges</span>
            <span class="n">g_pos</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">complement</span><span class="p">(</span><span class="n">g_neg</span><span class="p">)</span>
            <span class="c1"># Iterate until n1 has no more possible connections</span>
            <span class="n">neigbs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">g_pos</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">n1</span><span class="p">))</span>
            <span class="n">neigbs</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">isect</span><span class="p">(</span><span class="n">neigbs</span><span class="p">,</span> <span class="n">unused</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;num = </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">num</span><span class="p">,))</span>
    <span class="k">return</span> <span class="n">num</span></div>


<div class="viewcode-block" id="nx_mincut_edges_weighted"><a class="viewcode-back" href="../../utool.html#utool.util_graph.nx_mincut_edges_weighted">[docs]</a><span class="k">def</span> <span class="nf">nx_mincut_edges_weighted</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">capacity</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">):</span>
    <span class="c1"># http://stackoverflow.com/questions/33332462/minimum-s-t-edge-cut-which-takes-edge-weight-into-consideration</span>
    <span class="n">cut_weight</span><span class="p">,</span> <span class="n">partitions</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">minimum_cut</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">capacity</span><span class="o">=</span><span class="n">capacity</span><span class="p">)</span>
    <span class="n">edge_cut_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p1_node</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">p2_node</span> <span class="ow">in</span> <span class="n">partitions</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">G</span><span class="o">.</span><span class="n">has_edge</span><span class="p">(</span><span class="n">p1_node</span><span class="p">,</span> <span class="n">p2_node</span><span class="p">):</span>
                <span class="n">edge_cut_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p1_node</span><span class="p">,</span> <span class="n">p2_node</span><span class="p">))</span>
    <span class="c1"># assert edge_cut_list == nx_edges_between(G, partitions[0], partitions[1])</span>
    <span class="k">return</span> <span class="n">edge_cut_list</span></div>


<div class="viewcode-block" id="weighted_diamter"><a class="viewcode-back" href="../../utool.html#utool.util_graph.weighted_diamter">[docs]</a><span class="k">def</span> <span class="nf">weighted_diamter</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">all_pairs_shortest_path_length</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">all_pairs_dijkstra_path_length</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="n">eccentricities</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dists</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">dists</span> <span class="ow">in</span> <span class="n">distances</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">eccentricities</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dists</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">dists</span> <span class="ow">in</span> <span class="n">distances</span><span class="p">)</span>
    <span class="n">diameter</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">eccentricities</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">diameter</span></div>


<div class="viewcode-block" id="mincost_diameter_augment"><a class="viewcode-back" href="../../utool.html#utool.util_graph.mincost_diameter_augment">[docs]</a><span class="k">def</span> <span class="nf">mincost_diameter_augment</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">max_cost</span><span class="p">,</span> <span class="n">candidates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cost</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    PROBLEM: Bounded Cost Minimum Diameter Edge Addition (BCMD)</span>

<span class="sd">    Args:</span>
<span class="sd">        graph (nx.Graph): input graph</span>
<span class="sd">        max_cost (float): maximum weighted diamter of the graph</span>
<span class="sd">        weight (str): key of the edge weight attribute</span>
<span class="sd">        cost (str): key of the edge cost attribute</span>
<span class="sd">        candidates (list): set of non-edges, optional, defaults</span>
<span class="sd">            to the complement of the graph</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: if no solution exists</span>
<span class="sd">        list: minimum cost edges if solution exists</span>

<span class="sd">    Notes:</span>
<span class="sd">        We are given a graph G = (V, E) with an edge weight function w, an edge</span>
<span class="sd">        cost function c, an a maximum cost B.</span>

<span class="sd">        The goal is to find a set of candidate non-edges F.</span>

<span class="sd">        Let x[e] in {0, 1} denote if a non-edge e is excluded or included.</span>

<span class="sd">        minimize sum(c(e) * x[e] for e in F)</span>
<span class="sd">        such that</span>
<span class="sd">        weighted_diamter(graph.union({e for e in F if x[e]})) &lt;= B</span>

<span class="sd">    References:</span>
<span class="sd">        https://www.cse.unsw.edu.au/~sergeg/papers/FratiGGM13isaac.pdf</span>
<span class="sd">        http://www.cis.upenn.edu/~sanjeev/papers/diameter.pdf</span>
<span class="sd">        http://dl.acm.org/citation.cfm?id=2953882</span>

<span class="sd">    Notes:</span>
<span class="sd">        There is a 4-Approximation of the BCMD problem</span>
<span class="sd">        Running time is O((3 ** B * B ** 3 + n + log(B * n)) * B * n ** 2)</span>

<span class="sd">        This algorithm usexs a clustering approach to find a set C, of B + 1</span>
<span class="sd">        cluster centers.  Then we create a minimum height rooted tree, T = (U</span>
<span class="sd">        \subseteq V, D) so that C \subseteq U.  This tree T approximates an</span>
<span class="sd">        optimal B-augmentation.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; # ENABLE_DOCTEST</span>
<span class="sd">        &gt;&gt;&gt; from utool.util_graph import *  # NOQA</span>
<span class="sd">        &gt;&gt;&gt; import utool as ut</span>
<span class="sd">        &gt;&gt;&gt; graph = nx.Graph()</span>
<span class="sd">        &gt;&gt;&gt; if nx.__version__.startswith(&#39;1&#39;):</span>
<span class="sd">        &gt;&gt;&gt;     nx.add_path = nx.Graph.add_path</span>
<span class="sd">        &gt;&gt;&gt; nx.add_path(graph, range(6))</span>
<span class="sd">        &gt;&gt;&gt; #cost_func   = lambda e: e[0] + e[1]</span>
<span class="sd">        &gt;&gt;&gt; cost_func   = lambda e: 1</span>
<span class="sd">        &gt;&gt;&gt; weight_func = lambda e: (e[0]) / e[1]</span>
<span class="sd">        &gt;&gt;&gt; comp_graph = nx.complement(graph)</span>
<span class="sd">        &gt;&gt;&gt; nx.set_edge_attributes(graph, name=&#39;cost&#39;, values={e: cost_func(e) for e in graph.edges()})</span>
<span class="sd">        &gt;&gt;&gt; nx.set_edge_attributes(graph, name=&#39;weight&#39;, values={e: weight_func(e) for e in graph.edges()})</span>
<span class="sd">        &gt;&gt;&gt; nx.set_edge_attributes(comp_graph, name=&#39;cost&#39;, values={e: cost_func(e) for e in comp_graph.edges()})</span>
<span class="sd">        &gt;&gt;&gt; nx.set_edge_attributes(comp_graph, name=&#39;weight&#39;, values={e: weight_func(e) for e in comp_graph.edges()})</span>
<span class="sd">        &gt;&gt;&gt; candidates = list(comp_graph.edges(data=True))</span>
<span class="sd">        &gt;&gt;&gt; max_cost = 2</span>
<span class="sd">        &gt;&gt;&gt; cost = &#39;cost&#39;</span>
<span class="sd">        &gt;&gt;&gt; weight = &#39;weight&#39;</span>
<span class="sd">        &gt;&gt;&gt; best_edges = mincost_diameter_augment(graph, max_cost, candidates, weight, cost)</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;best_edges = %r&#39; % (best_edges,))</span>
<span class="sd">        &gt;&gt;&gt; soln_edges = greedy_mincost_diameter_augment(graph, max_cost, candidates, weight, cost)</span>
<span class="sd">        &gt;&gt;&gt; print(&#39;soln_edges = %r&#39; % (soln_edges,))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>
    <span class="kn">import</span> <span class="nn">operator</span> <span class="k">as</span> <span class="nn">op</span>

    <span class="k">if</span> <span class="n">candidates</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">complement</span><span class="p">()</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">augment_add</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
        <span class="n">aug_graph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">aug_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">aug_graph</span>

    <span class="k">def</span> <span class="nf">solution_energy</span><span class="p">(</span><span class="n">chosen_edges</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">chosen_edges</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">weight</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="n">chosen_edges</span><span class="p">)</span>

    <span class="n">variable_basis</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">]</span>
    <span class="n">best_energy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">best_soln</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">soln_generator</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">variable_basis</span><span class="p">)</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">variable_basis</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="mi">3000</span><span class="p">:</span>
        <span class="c1"># Let the user know that it might take some time to find a solution</span>
        <span class="n">soln_generator</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">ProgIter</span><span class="p">(</span>
            <span class="n">soln_generator</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;BruteForce BCMD&#39;</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">length</span>
        <span class="p">)</span>
    <span class="c1"># Brute force solution</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">soln_generator</span><span class="p">:</span>
        <span class="n">chosen_edges</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="n">aug_graph</span> <span class="o">=</span> <span class="n">augment_add</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">chosen_edges</span><span class="p">)</span>
        <span class="n">total_cost</span> <span class="o">=</span> <span class="n">weighted_diamter</span><span class="p">(</span><span class="n">aug_graph</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">cost</span><span class="p">)</span>
        <span class="n">energy</span> <span class="o">=</span> <span class="n">solution_energy</span><span class="p">(</span><span class="n">chosen_edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">total_cost</span> <span class="o">&lt;=</span> <span class="n">max_cost</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">energy</span> <span class="o">&lt;</span> <span class="n">best_energy</span><span class="p">:</span>
                <span class="n">best_energy</span> <span class="o">=</span> <span class="n">energy</span>
                <span class="n">best_soln</span> <span class="o">=</span> <span class="n">x</span>

    <span class="n">best_edges</span> <span class="o">=</span> <span class="n">ut</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">best_soln</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">best_edges</span></div>


<div class="viewcode-block" id="greedy_mincost_diameter_augment"><a class="viewcode-back" href="../../utool.html#utool.util_graph.greedy_mincost_diameter_augment">[docs]</a><span class="k">def</span> <span class="nf">greedy_mincost_diameter_augment</span><span class="p">(</span>
    <span class="n">graph</span><span class="p">,</span> <span class="n">max_cost</span><span class="p">,</span> <span class="n">candidates</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cost</span><span class="o">=</span><span class="kc">None</span>
<span class="p">):</span>
    <span class="c1"># import utool as ut</span>

    <span class="k">def</span> <span class="nf">solution_cost</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">weighted_diamter</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">cost</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">solution_energy</span><span class="p">(</span><span class="n">chosen_edges</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">chosen_edges</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">weight</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="ow">in</span> <span class="n">chosen_edges</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">augment_add</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
        <span class="n">aug_graph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">aug_graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">aug_graph</span>

    <span class="k">def</span> <span class="nf">augment_remove</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
        <span class="n">aug_graph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">aug_graph</span><span class="o">.</span><span class="n">remove_edges_from</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">aug_graph</span>

    <span class="n">base_cost</span> <span class="o">=</span> <span class="n">solution_cost</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
    <span class="c1"># base_energy = 0</span>

    <span class="n">full_graph</span> <span class="o">=</span> <span class="n">augment_add</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">candidates</span><span class="p">)</span>
    <span class="n">full_cost</span> <span class="o">=</span> <span class="n">solution_cost</span><span class="p">(</span><span class="n">full_graph</span><span class="p">)</span>
    <span class="c1"># full_energy = solution_energy(candidates)</span>

    <span class="k">def</span> <span class="nf">greedy_improvement</span><span class="p">(</span><span class="n">soln_graph</span><span class="p">,</span> <span class="n">available_candidates</span><span class="p">,</span> <span class="n">base_cost</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Choose edge that results in the best improvement</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">best_loss</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">best_cost</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">best_energy</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">best_e</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">best_graph</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">available_candidates</span><span class="p">:</span>
            <span class="n">aug_graph</span> <span class="o">=</span> <span class="n">augment_add</span><span class="p">(</span><span class="n">soln_graph</span><span class="p">,</span> <span class="p">[</span><span class="n">e</span><span class="p">])</span>
            <span class="n">aug_cost</span> <span class="o">=</span> <span class="n">solution_cost</span><span class="p">(</span><span class="n">aug_graph</span><span class="p">)</span>
            <span class="n">aug_energy</span> <span class="o">=</span> <span class="n">solution_energy</span><span class="p">([</span><span class="n">e</span><span class="p">])</span>

            <span class="c1"># We don&#39;t want to go over if possible</span>
            <span class="n">aug_loss</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">aug_cost</span> <span class="o">-</span> <span class="n">max_cost</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">best_loss</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">aug_loss</span> <span class="o">&lt;=</span> <span class="n">best_loss</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">best_energy</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">aug_energy</span> <span class="o">&lt;</span> <span class="n">best_energy</span><span class="p">:</span>
                    <span class="n">best_loss</span> <span class="o">=</span> <span class="n">aug_loss</span>
                    <span class="n">best_e</span> <span class="o">=</span> <span class="n">e</span>
                    <span class="n">best_graph</span> <span class="o">=</span> <span class="n">aug_graph</span>
                    <span class="n">best_cost</span> <span class="o">=</span> <span class="n">aug_cost</span>
                    <span class="n">best_energy</span> <span class="o">=</span> <span class="n">aug_energy</span>

        <span class="k">if</span> <span class="n">best_e</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">best_cost</span><span class="p">,</span> <span class="n">best_graph</span><span class="p">,</span> <span class="n">best_energy</span><span class="p">,</span> <span class="n">best_e</span>

    <span class="kn">import</span> <span class="nn">warnings</span>

    <span class="k">if</span> <span class="n">full_cost</span> <span class="o">&gt;</span> <span class="n">max_cost</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;no feasible solution&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">soln_graph</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">available_candidates</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[:]</span>
        <span class="n">soln_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">soln_energy</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">soln_cost</span> <span class="o">=</span> <span class="n">base_cost</span>

        <span class="c1"># Add edges to the solution until the cost is feasible</span>
        <span class="k">while</span> <span class="n">soln_cost</span> <span class="o">&gt;</span> <span class="n">max_cost</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">available_candidates</span><span class="p">):</span>
            <span class="n">tup</span> <span class="o">=</span> <span class="n">greedy_improvement</span><span class="p">(</span><span class="n">soln_graph</span><span class="p">,</span> <span class="n">available_candidates</span><span class="p">,</span> <span class="n">soln_cost</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tup</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;no improvement found&#39;</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="n">soln_cost</span><span class="p">,</span> <span class="n">soln_graph</span><span class="p">,</span> <span class="n">best_energy</span><span class="p">,</span> <span class="n">best_e</span> <span class="o">=</span> <span class="n">tup</span>
            <span class="n">soln_energy</span> <span class="o">+=</span> <span class="n">best_energy</span>
            <span class="n">soln_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best_e</span><span class="p">)</span>
            <span class="n">available_candidates</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">best_e</span><span class="p">)</span>

        <span class="c1"># Check to see we can remove edges while maintaining feasibility</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">soln_edges</span><span class="p">[:]:</span>
            <span class="n">aug_graph</span> <span class="o">=</span> <span class="n">augment_remove</span><span class="p">(</span><span class="n">soln_graph</span><span class="p">,</span> <span class="p">[</span><span class="n">e</span><span class="p">])</span>
            <span class="n">aug_cost</span> <span class="o">=</span> <span class="n">solution_cost</span><span class="p">(</span><span class="n">aug_graph</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aug_cost</span> <span class="o">&lt;=</span> <span class="n">soln_cost</span><span class="p">:</span>
                <span class="n">soln_cost</span> <span class="o">=</span> <span class="n">aug_cost</span>
                <span class="n">soln_graph</span> <span class="o">=</span> <span class="n">aug_graph</span>
                <span class="n">soln_edges</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">soln_edges</span></div>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CommandLine:</span>
<span class="sd">        python -m utool.util_graph --allexamples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">multiprocessing</span>

    <span class="n">multiprocessing</span><span class="o">.</span><span class="n">freeze_support</span><span class="p">()</span>  <span class="c1"># for win32</span>
    <span class="kn">import</span> <span class="nn">utool</span> <span class="k">as</span> <span class="nn">ut</span>  <span class="c1"># NOQA</span>

    <span class="n">ut</span><span class="o">.</span><span class="n">doctest_funcs</span><span class="p">()</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">wbia-vtool</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../utool.html">utool package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../utool.html">utool</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2020, Wild Me.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.8.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>